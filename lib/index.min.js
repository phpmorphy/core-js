/**
 * @license
 * Copyright (c) 2020 UMI
 * MIT Licensed
 */

var umi = (function (exports) {
    'use strict';

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Базовый класс для работы с адресами.
     * @class
     */
    var Address = /** @class */ (function () {
        /**
         * @param {Uint8Array} [bytes] Адрес в бинарном виде, длина 34 байта.
         * @throws {Error}
         */
        function Address(bytes) {
            /**
             * Адрес в бинарном виде, длина 34 байта.
             * @type {Uint8Array}
             * @private
             * @internal
             */
            this._bytes = new Uint8Array(Address.LENGTH);
            if (bytes === undefined) {
                this.version = Address.Umi;
            }
            else {
                if (!(bytes instanceof Uint8Array)) {
                    throw new Error('bytes type must be Uint8Array');
                }
                if (bytes.byteLength !== Address.LENGTH) {
                    throw new Error('bytes length must be 34 bytes');
                }
                this._bytes.set(bytes);
            }
        }
        Object.defineProperty(Address, "LENGTH", {
            /**
             * Длина адреса в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 34; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address, "Genesis", {
            /**
             * Версия Genesis-адрса.
             * @type {number}
             * @constant
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address, "Umi", {
            /**
             * Версия Umi-адреса.
             * @type {number}
             * @constant
             */
            get: function () { return 21929; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "bytes", {
            /**
             * Адрес в бинарном виде, длина 34 байта.
             * @type {Uint8Array}
             * @readonly
             */
            get: function () {
                var b = new Uint8Array(this._bytes.byteLength);
                b.set(this._bytes);
                return b;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "version", {
            /**
             * Версия адреса, префикс в числовом виде.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                // version length = 2
                // version offset = 0
                return new DataView(this._bytes.buffer).getUint16(0);
            },
            set: function (version) {
                versionToPrefix(version); // validation
                // tslint:disable-next-line:no-bitwise
                new DataView(this._bytes.buffer).setUint16(0, (version & 0x7FFF));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает версию адреса и возвращяет this.
         * @param {number} version Версия адреса.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(Address.prototype, "publicKey", {
            /**
             * Публичный ключ.
             * @type {PublicKey}
             * @throws {Error}
             */
            get: function () {
                // public key begin = 2
                return new PublicKey(this._bytes.subarray(2));
            },
            set: function (publicKey) {
                if (!(publicKey instanceof PublicKey)) {
                    throw new Error('publicKey type must be PublicKey');
                }
                // public key offset = 2
                this._bytes.set(publicKey.bytes, 2);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает публичный ключи и возвращяет this.
         * @param {PublicKey} publicKey Публичный ключ.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPublicKey = function (publicKey) {
            this.publicKey = publicKey;
            return this;
        };
        Object.defineProperty(Address.prototype, "prefix", {
            /**
             * Префикс адреса, три символа латиницы в нижнем регистре.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return versionToPrefix(this.version);
            },
            set: function (prefix) {
                this.version = prefixToVersion(prefix);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает префикс адреса и возвращяет this.
         * @param {string} prefix Префикс адреса, три символа латиницы в нижнем регистре.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Address.prototype, "bech32", {
            /**
             * Адрес в формате Bech32, длина 62 символа.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return encode(this._bytes);
            },
            set: function (bech32) {
                validateStr(bech32);
                this._bytes.set(decode(bech32));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает адрес в формате Bech32.
         * @param {string} bech32 Адрес в формате Bech32, длина 62 символа.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setBech32 = function (bech32) {
            this.bech32 = bech32;
            return this;
        };
        /**
         * Статический фабричный метод, создающий объект из адреса в формате Bech32.
         * @param {string} bech32 Адрес в формате Bech32, длина 62 символа.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromBech32 = function (bech32) {
            return new Address().setBech32(bech32);
        };
        /**
         * Статический фабричный метод, создающий объект из публичного или приватного ключа.
         * @param {PublicKey|SecretKey} key Публичный или приватный ключ.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromKey = function (key) {
            if (key instanceof SecretKey) {
                return new Address().setPublicKey(key.publicKey);
            }
            if (key instanceof PublicKey) {
                return new Address().setPublicKey(key);
            }
            throw new Error('key type must be PublicKey or SecretKey');
        };
        return Address;
    }());
    /**
     * Базовый класс для работы с блоками.
     * @class
     */
    var Block = /** @class */ (function () {
        function Block() {
        }
        return Block;
    }());
    /**
     * Базовый класс для работы с заголовками блоков.
     * @class
     */
    var BlockHeader = /** @class */ (function () {
        function BlockHeader() {
        }
        return BlockHeader;
    }());
    /**
     * Базовый класс для работы с публичными ключами.
     * @class
     */
    var PublicKey = /** @class */ (function () {
        /**
         * @param {Uint8Array} bytes Публичный ключ в формате libsodium, 32 байта (256 бит).
         * @throws {Error}
         */
        function PublicKey(bytes) {
            /**
             * Публичный ключ в бинарном виде. В формате libsodium.
             * @type {Uint8Array}
             * @private
             * @internal
             */
            this._bytes = new Uint8Array(PublicKey.LENGTH);
            validateUint8Array(bytes, PublicKey.LENGTH);
            this._bytes.set(bytes);
        }
        Object.defineProperty(PublicKey, "LENGTH", {
            /**
             * Длина публичного ключа в формате libsodium в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 32; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey, "SIGNATURE_LENGTH", {
            /**
             * Длина цифровой подписи в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "signatureLength", {
            /**
             * Длина цифровой подписи в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return PublicKey.SIGNATURE_LENGTH; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "bytes", {
            /**
             * Публичный ключ в формате libsodium, 32 байта (256 бит).
             * @type {Uint8Array}
             * @readonly
             */
            get: function () {
                var b = new Uint8Array(this._bytes.byteLength);
                b.set(this._bytes);
                return b;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Проверяет цифровую подпись.
         * @param {Uint8Array} signature Подпись, 64 байта.
         * @param {Uint8Array} message Сообщение
         * @returns {boolean}
         * @throws {Error}
         * @example
         * let key = new Uint8Array(32)
         * let sig = new Uint8Array(64)
         * let msg = new Uint8Array(1)
         * let ver = new PublicKey(key).verifySignature(sig, msg)
         */
        PublicKey.prototype.verifySignature = function (signature, message) {
            validateUint8Array(signature, PublicKey.SIGNATURE_LENGTH);
            validateUint8Array(message);
            return verify(signature, message, this._bytes);
        };
        return PublicKey;
    }());
    /**
     * Базовый класс для работы с приватными ключами.
     * @class
     */
    var SecretKey = /** @class */ (function () {
        /**
         * @param {Uint8Array} bytes Приватный ключ в бинарном виде.
         * В формате libsodium, 64 байта (512 бит).
         * @throws {Error}
         */
        function SecretKey(bytes) {
            /**
             * Приватный ключ в бинарном виде. В формате libsodium.
             * @type {Uint8Array}
             * @private
             * @internal
             */
            this._bytes = new Uint8Array(SecretKey.LENGTH);
            validateUint8Array(bytes, SecretKey.LENGTH);
            this._bytes.set(bytes);
        }
        Object.defineProperty(SecretKey, "LENGTH", {
            /**
             * Длина приватного ключа в формате libsodium в байтах.
             * @type {number}
             * @internal
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "bytes", {
            /**
             * Приватный ключ в бинарном виде. В формате libsodium, 64 байта (512 бит).
             * @type {Uint8Array}
             * @readonly
             */
            get: function () {
                var b = new Uint8Array(this._bytes.byteLength);
                b.set(this._bytes);
                return b;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "publicKey", {
            /**
             * Публичный ключ, соотвествующий приватному ключу.
             * @type {PublicKey}
             * @readonly
             */
            get: function () {
                return new PublicKey(publicKeyFromSecretKey(this._bytes));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Создает цифровую подпись сообщения.
         * @param {Uint8Array} message Сообщение, которое необходимо подписать.
         * @returns {Uint8Array} Цифровая подпись длиной 64 байта (512 бит).
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let msg = new Uint8Array(1)
         * let sig = SecretKey.fromSeed(seed).sign(msg)
         */
        SecretKey.prototype.sign = function (message) {
            validateUint8Array(message);
            return sign(message, this._bytes);
        };
        /**
         * Статический фабричный метод, создающий приватный ключ из seed.
         * Libsodium принимает seed длиной 32 байта (256 бит), если длина
         * отличается, то берется sha256 хэш.
         * @param {Uint8Array} seed Seed длиной от 0 до 128 байт.
         * @returns {SecretKey}
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let key = SecretKey.fromSeed(seed)
         */
        SecretKey.fromSeed = function (seed) {
            validateUint8Array(seed);
            if (seed.byteLength === 32) {
                return new SecretKey(secretKeyFromSeed(seed));
            }
            return new SecretKey(secretKeyFromSeed(sha256(seed)));
        };
        return SecretKey;
    }());
    /**
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransaction = /** @class */ (function () {
        /**
         * @param {Uint8Array} [bytes] Транзакция в бинарном виде, 150 байт.
         * @throws {Error}
         * @private
         */
        function AbstractTransaction(bytes) {
            /**
             * Транзакция в бинарном виде.
             * @type {Uint8Array}
             * @private
             * @internal
             */
            this._bytes = new Uint8Array(AbstractTransaction.LENGTH);
            /**
             * Транзакция в бинарном виде.
             * @type {DataView}
             * @private
             * @internal
             */
            this._view = new DataView(this._bytes.buffer);
            /**
             * Заполоненные свойства.
             * @type {Object}
             * @private
             * @internal
             */
            this._fieldsMap = {};
            if (bytes !== undefined) {
                validateUint8Array(bytes, AbstractTransaction.LENGTH);
                this._bytes.set(bytes);
                this._setFields([
                    'version', 'sender', 'recipient', 'value', 'prefix',
                    'name', 'profitPercent', 'feePercent', 'nonce', 'signature'
                ]);
            }
        }
        Object.defineProperty(AbstractTransaction, "LENGTH", {
            /**
             * Длина транзакции в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 150; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "Genesis", {
            /**
             * Genesis-транзакция.
             * Может быть добавлена только в Genesis-блок.
             * Адрес отправителя должен иметь префикс genesis, адрес получаетеля - umi.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('genesis')
             * let recipient = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.Genesis).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "Basic", {
            /**
             * Стандартная транзакция. Перевод монет из одного кошелька в другой.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let recipient = Address.fromKey(secKey).setPrefix('aaa')
             * let tx = new Transaction().
             *   setVersion(Transaction.Basic).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateStructure", {
            /**
             * Создание новой структуры.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('🙂').
             *   setProfitPercent(100).
             *   setFeePercent(0).
             *   sign(secKey)
             */
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateStructure", {
            /**
             * Обновление настроек существующей структуры.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('🙂').
             *   setProfitPercent(500).
             *   setFeePercent(2000).
             *   sign(secKey)
             */
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateProfitAddress", {
            /**
             * Изменение адреса для начисления профита.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newPrf = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateProfitAddress).
             *   setSender(sender).
             *   setRecipient(newPrf).
             *   sign(secKey)
             */
            get: function () { return 4; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateFeeAddress", {
            /**
             * Изменение адреса на который переводоится комиссия.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newFee = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateFeeAddress).
             *   setSender(sender).
             *   setRecipient(newFee).
             *   sign(secKey)
             */
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateTransitAddress", {
            /**
             * Активация транзитного адреса.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 6; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "DeleteTransitAddress", {
            /**
             * Деактивация транзитного адреса.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.DeleteTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 7; },
            enumerable: false,
            configurable: true
        });
        /**
         * Проверить наличие свойства.
         * @param {string[]} fields
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransaction.prototype._checkFields = function (fields) {
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var field = fields_1[_i];
                if (!Object.prototype.hasOwnProperty.call(this._fieldsMap, field)) {
                    throw new Error(field + " must be set");
                }
            }
        };
        /**
         * Отметить свойство как установленное.
         * @param {string[]} fields
         * @private
         * @internal
         */
        AbstractTransaction.prototype._setFields = function (fields) {
            for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
                var field = fields_2[_i];
                this._fieldsMap[field] = true;
            }
        };
        return AbstractTransaction;
    }());
    /**
     * Базовый класс для работы с транзакциями.
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransactionBase = /** @class */ (function (_super) {
        __extends(AbstractTransactionBase, _super);
        function AbstractTransactionBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AbstractTransactionBase.prototype, "bytes", {
            /**
             * Транзакция в бинарном виде, 150 байт.
             * @type {Uint8Array}
             * @readonly
             */
            get: function () {
                var b = new Uint8Array(this._bytes.byteLength);
                b.set(this._bytes);
                return b;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "hash", {
            /**
             * Хэш транзакции, sha256 от всех 150 байт.
             * @type {Uint8Array}
             * @readonly
             */
            get: function () {
                return sha256(this._bytes);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "version", {
            /**
             * Версия (тип) транзакции.
             * Обязательное поле, необходимо задать сразу после создания новой транзакции.
             * Изменять тип транзакции, после того как он был задан, нельзя.
             * @type {number}
             * @throws {Error}
             * @see Transaction.Genesis
             * @see Transaction.Basic
             * @see Transaction.CreateStructure
             * @see Transaction.UpdateStructure
             * @see Transaction.UpdateProfitAddress
             * @see Transaction.UpdateFeeAddress
             * @see Transaction.CreateTransitAddress
             * @see Transaction.DeleteTransitAddress
             */
            get: function () {
                this._checkFields(['version']);
                return this._bytes[0];
            },
            set: function (version) {
                if (Object.prototype.hasOwnProperty.call(this._fieldsMap, 'version')) {
                    throw new Error('could not update version');
                }
                validateInt(version, AbstractTransactionBase.Genesis, AbstractTransactionBase.DeleteTransitAddress);
                this._bytes[0] = version;
                this._setFields(['version']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает версию и возвращяет this.
         * @param {number} version Версия адреса.
         * @returns {this}
         * @throws {Error}
         * @see Transaction.Genesis
         * @see Transaction.Basic
         * @see Transaction.CreateStructure
         * @see Transaction.UpdateStructure
         * @see Transaction.UpdateProfitAddress
         * @see Transaction.UpdateFeeAddress
         * @see Transaction.CreateTransitAddress
         * @see Transaction.DeleteTransitAddress
         */
        AbstractTransactionBase.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "sender", {
            /**
             * Отправитель. Доступно для всех типов транзакций.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['sender']);
                // sender length = 34
                // sender begin = 1
                // sender end = 35
                return new Address(this._bytes.subarray(1, 35));
            },
            set: function (address) {
                this._checkFields(['version']);
                if (!(address instanceof Address)) {
                    throw new Error('address type must be Address');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Genesis) {
                    throw new Error('address version must be genesis');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    address.version === Address.Genesis) {
                    throw new Error('address version must not be genesis');
                }
                // sender length = 34
                // sender begin = 1
                this._bytes.set(address.bytes, 1);
                this._setFields(['sender']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает отправителя и возвращяет this.
         * @param {Address} address Адрес получателя.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSender = function (address) {
            this.sender = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "recipient", {
            /**
             * Получатель.
             * Недоступно для транзакций CreateStructure и UpdateStructure.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                this._checkFields(['recipient']);
                // recipient length = 34
                // recipient begin = 35
                // recipient enf = 69
                return new Address(this._bytes.subarray(35, 69));
            },
            set: function (address) {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                if (!(address instanceof Address)) {
                    throw new Error('recipient type must be Address');
                }
                if (address.version === Address.Genesis) {
                    throw new Error('recipient version must not be genesis');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Umi) {
                    throw new Error('recipient version must be umi');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    this.version !== AbstractTransactionBase.Basic &&
                    address.version === Address.Umi) {
                    throw new Error('recipient version must not be umi');
                }
                // recipient length = 34
                // recipient begin = 35
                this._bytes.set(address.bytes, 35);
                this._setFields(['recipient']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает получателя и возвращяет this.
         * Доступно для всех типов транзакций кроме CreateStructure и UpdateStructure.
         * @param {Address} address Адрес получателя.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setRecipient = function (address) {
            this.recipient = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "value", {
            /**
             * Сумма перевода в UMI-центах, цело число в промежутке от 1 до 18446744073709551615.
             * Из-за ограничений JavaScript максимальное доступное значение 9007199254740991.
             * Доступно только для Genesis и Basic транзакций.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                this._checkFields(['value']);
                // value offset = 69
                if (this._view.getUint16(69) > 0x001f) {
                    throw new Error('value is not safe integer');
                }
                return this._view.getUint32(69) * 4294967296 +
                    this._view.getUint32(69 + 4);
            },
            set: function (value) {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                validateInt(value, 1, 9007199254740991);
                // value offset = 69
                // tslint:disable-next-line:no-bitwise
                this._view.setInt32(69 + 4, value | 0);
                this._view.setInt32(69, (value - this._view.getUint32(69 + 4)) / 4294967296);
                this._setFields(['value']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает сумму и возвращяет this.
         * Принимает значения в промежутке от 1 до 9007199254740991.
         * Доступно только для Genesis и Basic транзакций.
         * @param {number} value
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setValue = function (value) {
            this.value = value;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "nonce", {
            /**
             * Nonce, целое число в промежутке от 0 до 18446744073709551615.
             * Из-за ограничений JavaScript максимальное доступное значение 9007199254740991.
             * Генерируется автоматичеки при вызове sign().
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['nonce']);
                // nonce offset = 77
                if (this._view.getUint16(77) > 0x001f) {
                    throw new Error('nonce is not safe integer');
                }
                return this._view.getUint32(77) * 4294967296 +
                    this._view.getUint32(77 + 4);
            },
            set: function (nonce) {
                validateInt(nonce, 0, 9007199254740991);
                // nonce offset = 77
                // tslint:disable-next-line:no-bitwise
                this._view.setInt32(77 + 4, nonce | 0);
                this._view.setInt32(77, (nonce - this._view.getUint32(77 + 4)) / 4294967296);
                this._setFields(['nonce']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает nonce и возвращяет this.
         * @param {number} nonce Nonce, целое числов промежутке от 0 до 9007199254740991.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setNonce = function (nonce) {
            this.nonce = nonce;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "signature", {
            /**
             * Цифровая подпись транзкции, длина 64 байта.
             * Генерируется автоматически при вызове sign().
             * @type {Uint8Array}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['signature']);
                // signature length = 64
                var len = this.sender.publicKey.signatureLength;
                var sig = new Uint8Array(len);
                // signature offset = 85
                sig.set(this._bytes.subarray(85, 85 + len));
                return sig;
            },
            set: function (signature) {
                this._checkFields(['version', 'sender']);
                validateUint8Array(signature, this.sender.publicKey.signatureLength);
                // signature offset = 85
                this._bytes.set(signature, 85);
                this._setFields(['signature']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает цифровую подпись и возвращяет this.
         * @param {Uint8Array} signature Подпись, длина 64 байта.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSignature = function (signature) {
            this.signature = signature;
            return this;
        };
        /**
         * Подписать транзакцию приватным ключем.
         * @param {SecretKey} secretKey
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.sign = function (secretKey) {
            this._checkFields(['version', 'sender']);
            if (!(secretKey instanceof SecretKey)) {
                throw new Error('secretKey type must be SecretKey');
            }
            // unsigned begin = 0
            // unsigned end = 85
            var msg = this._bytes.subarray(0, 85);
            this.signature = secretKey.sign(msg);
            return this;
        };
        /**
         * Проверить транзакцию на соотвествие формальным правилам.
         * @returns {boolean}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.verify = function () {
            this._checkFields(['version', 'sender', 'signature']);
            // unsigned begin = 0
            // unsigned end = 85
            var msg = this._bytes.subarray(0, 85);
            return this.sender.publicKey.verifySignature(this.signature, msg);
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsBasic = function () {
            var versions = [AbstractTransaction.Genesis, AbstractTransaction.Basic];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsNotStruct = function () {
            var versions = [AbstractTransaction.CreateStructure, AbstractTransaction.UpdateStructure];
            if (versions.indexOf(this.version) !== -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        return AbstractTransactionBase;
    }(AbstractTransaction));
    /**
     * Класс для работы с транзакциями.
     * @class
     * @param {Uint8Array} [bytes] Транзакция в бинарном виде, 150 байт.
     * @throws {Error}
     */
    var Transaction = /** @class */ (function (_super) {
        __extends(Transaction, _super);
        function Transaction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        Transaction.prototype._checkVersionIsStruct = function () {
            var versions = [Transaction.CreateStructure, Transaction.UpdateStructure];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        Object.defineProperty(Transaction.prototype, "prefix", {
            /**
             * Префикс адресов, принадлежащих структуре.
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['prefix']);
                // prefix offset = 35
                return versionToPrefix(this._view.getUint16(35));
            },
            set: function (prefix) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                // prefix offset = 35
                this._view.setUint16(35, prefixToVersion(prefix));
                this._setFields(['prefix']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает префикс и возвращяет this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {string} prefix Префикс адресов, принадлежащих структуре.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "name", {
            /**
             * Название структуры в кодировке UTF-8.
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['name']);
                // name offset = 41
                var txt = this._bytes.subarray(41 + 1, 41 + 1 + this._bytes[41]);
                return Utf8Decode(txt);
            },
            set: function (name) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                if (typeof name !== 'string') {
                    throw new Error('name type must be a string');
                }
                // name length = 36
                var txt = Utf8Encode(name);
                if (txt.byteLength >= 36) {
                    throw new Error('name is too long');
                }
                // name offset = 41
                this._bytes[41] = txt.byteLength;
                this._bytes.set(txt, 41 + 1);
                this._setFields(['name']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает название структуры.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {string} name Название структуры в кодировке UTF-8.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setName = function (name) {
            this.name = name;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "profitPercent", {
            /**
             * Профита в сотых долях процента с шагом в 0.01%.
             * Валидные значения от 100 до 500 (соотвественно от 1% до 5%).
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['profitPercent']);
                // profit offset = 37
                return this._view.getUint16(37);
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 100, 500);
                // profit offset = 37
                this._view.setUint16(37, percent);
                this._setFields(['profitPercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает процент профита и возвращяет this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {number} percent Профит в сотых долях процента с шагом в 0.01%. Валидные значения от 100 до 500 (соотвественно от 1% до 5%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setProfitPercent = function (percent) {
            this.profitPercent = percent;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "feePercent", {
            /**
             * Комиссия в сотых долях процента с шагом в 0.01%.
             * Валидные значения от 0 до 2000 (соотвественно от 0% до 20%).
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['feePercent']);
                // fee offset = 39
                return this._view.getUint16(39);
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 0, 2000);
                // fee offset = 39
                this._view.setUint16(39, percent);
                this._setFields(['feePercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает размер комисии и возвращяет this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {number} percent Комиссия в сотых долях процента с шагом в 0.01%. Валидные значения от 0 до 2000 (соотвественно от 0% до 20%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setFeePercent = function (percent) {
            this.feePercent = percent;
            return this;
        };
        return Transaction;
    }(AbstractTransactionBase));
    var alphabet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
    /**
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    function encode(bytes) {
        var version = (bytes[0] << 8) + bytes[1];
        var prefix = versionToPrefix(version);
        var data = convert8to5(bytes.subarray(2));
        var checksum = createChecksum(prefix, data);
        return prefix + '1' + data + checksum;
    }
    /**
     * @param {string} bech32
     * @returns {Uint8Array}
     */
    function decode(bech32) {
        if (bech32.length !== 62 && bech32.length !== 66) {
            throw new Error('bech32: invalid length');
        }
        var str = bech32.toLowerCase();
        var sepPos = str.lastIndexOf('1');
        if (sepPos === -1) {
            throw new Error('bech32: missing separator');
        }
        var pfx = str.slice(0, sepPos);
        var ver = prefixToVersion(pfx);
        var data = str.slice(sepPos + 1);
        checkAlphabet(data);
        verifyChecksum(pfx, data);
        var res = new Uint8Array(34);
        res.set(convert5to8(data.slice(0, -6)), 2);
        new DataView(res.buffer).setUint16(0, ver);
        return res;
    }
    function convert5to8(data) {
        var value = 0;
        var bits = 0;
        var bytes = strToBytes(data);
        var result = [];
        for (var i = 0; i < bytes.byteLength; i++) {
            value = (value << 5) | bytes[i];
            bits += 5;
            while (bits >= 8) {
                bits -= 8;
                result.push((value >> bits) & 0xff);
            }
        }
        if ((bits >= 5) || (value << (8 - bits)) & 0xff) {
            throw new Error('bech32: invalid data');
        }
        return new Uint8Array(result);
    }
    function convert8to5(data) {
        var value = 0;
        var bits = 0;
        var result = '';
        for (var i = 0; i < data.byteLength; i++) {
            value = (value << 8) | data[i];
            bits += 8;
            while (bits >= 5) {
                bits -= 5;
                result += alphabet[(value >> bits) & 0x1f];
            }
        }
        /** @istanbul ignore else */
        if (bits > 0) {
            result += alphabet[(value << (5 - bits)) & 0x1f];
        }
        return result;
    }
    function createChecksum(prefix, data) {
        var bytes = strToBytes(data);
        var pfx = prefixExpand(prefix);
        var values = new Uint8Array(pfx.byteLength + bytes.byteLength + 6);
        values.set(pfx);
        values.set(bytes, pfx.byteLength);
        var poly = polyMod(values) ^ 1;
        var checksum = '';
        for (var i = 0; i < 6; i++) {
            checksum += alphabet[(poly >> 5 * (5 - i)) & 31];
        }
        return checksum;
    }
    function polyMod(values) {
        var gen = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
        var chk = 1;
        for (var i = 0; i < values.byteLength; i++) {
            var top_1 = chk >> 25;
            chk = (chk & 0x1ffffff) << 5 ^ values[i];
            for (var j = 0; j < 5; j++) {
                chk ^= ((top_1 >> j) & 1)
                    ? gen[j]
                    : 0;
            }
        }
        return chk;
    }
    function prefixExpand(prefix) {
        var res = new Uint8Array((prefix.length * 2) + 1);
        for (var i = 0; i < prefix.length; i++) {
            var ord = prefix.charCodeAt(i);
            res[i] = ord >> 5;
            res[i + prefix.length + 1] = ord & 31;
        }
        return res;
    }
    function strToBytes(str) {
        var bytes = [];
        for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
            var chr = str_1[_i];
            bytes.push(alphabet.indexOf(chr));
        }
        return new Uint8Array(bytes);
    }
    function verifyChecksum(prefix, data) {
        var pfx = prefixExpand(prefix);
        var bytes = strToBytes(data);
        var values = new Uint8Array(pfx.byteLength + bytes.byteLength);
        values.set(pfx);
        values.set(bytes, pfx.byteLength);
        var poly = polyMod(values);
        if (poly !== 1) {
            throw new Error('bech32: invalid checksum');
        }
    }
    function checkAlphabet(chars) {
        for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {
            var chr = chars_1[_i];
            if (alphabet.indexOf(chr) === -1) {
                throw new Error('bech32: invalid character');
            }
        }
    }
    /**
     * Конвертер цифровой версии префикса в текстовое представление.
     * @param {number} version
     * @returns {string}
     * @throws {Error}
     * @private
     */
    function versionToPrefix(version) {
        validateInt(version, 0, 65535);
        if (version === 0) {
            return 'genesis';
        }
        if ((version & 0x8000) === 0x8000) {
            throw new Error('bech32: incorrect version');
        }
        var a = (version & 0x7C00) >> 10;
        var b = (version & 0x03E0) >> 5;
        var c = (version & 0x001F);
        checkChars([a, b, c]);
        return String.fromCharCode((a + 96), (b + 96), (c + 96));
    }
    /**
     * Конвертер текстовой версии префикса в числовое представление.
     * @param {string} prefix
     * @returns {number}
     * @throws {Error}
     * @private
     */
    function prefixToVersion(prefix) {
        if (prefix === 'genesis') {
            return 0;
        }
        validateStr(prefix, 3);
        var a = prefix.charCodeAt(0) - 96;
        var b = prefix.charCodeAt(1) - 96;
        var c = prefix.charCodeAt(2) - 96;
        checkChars([a, b, c]);
        return (a << 10) + (b << 5) + c;
    }
    /**
     * @param {number[]} chars
     * @throws {Error}
     */
    function checkChars(chars) {
        for (var _i = 0, chars_2 = chars; _i < chars_2.length; _i++) {
            var chr = chars_2[_i];
            if (chr < 1 || chr > 26) {
                throw new Error('bech32: incorrect prefix character');
            }
        }
    }
    var gf0 = new Float64Array(16);
    var gf1 = new Float64Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    var D2 = new Float64Array([
        0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
        0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
    ]);
    var X = new Float64Array([
        0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
        0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
    ]);
    var Y = new Float64Array([
        0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
        0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
    ]);
    var L = new Float64Array([
        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
        0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
    ]);
    /**
     * @param {Uint8Array} r
     * @private
     * @internal
     */
    function reduce(r) {
        var x = new Float64Array(64);
        x.set(r);
        r.set(new Float64Array(64));
        modL(r, x);
    }
    /**
     * @param {Uint8Array} r
     * @param {Float64Array} x
     * @private
     * @internal
     */
    function modL(r, x) {
        var carry;
        var j;
        var k;
        for (var i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256); // carry = (x[j] + 128) >> 8;
                x[j] -= carry * 256; // x[j] -= carry << 8;
            }
            x[j] += carry;
            x[i] = 0;
        }
        modLSub(r, x);
    }
    function modLSub(r, x) {
        var carry = 0;
        for (var j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for (var j = 0; j < 32; j++) {
            x[j] -= carry * L[j];
        }
        for (var i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
    }
    /**
     * @param {Float64Array[]} p
     * @param {Float64Array[]} q
     * @param {Uint8Array} s
     * @private
     * @internal
     */
    function scalarmult(p, q, s) {
        var b;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (var i = 255; i >= 0; --i) {
            b = (s[(i / 8) | 0] >> (i & 7)) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    /**
     * @param {Float64Array[]} p
     * @param {Float64Array[]} q
     * @param {number} b
     * @private
     * @internal
     */
    function cswap(p, q, b) {
        for (var i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
        }
    }
    /**
     * @param {Float64Array[]} p
     * @param {Float64Array[]} q
     * @private
     * @internal
     */
    function add(p, q) {
        var a = new Float64Array(16);
        var b = new Float64Array(16);
        var c = new Float64Array(16);
        var d = new Float64Array(16);
        var e = new Float64Array(16);
        var f = new Float64Array(16);
        var g = new Float64Array(16);
        var h = new Float64Array(16);
        var t = new Float64Array(16);
        fnZ(a, p[1], p[0]);
        fnZ(t, q[1], q[0]);
        fnM(a, a, t);
        fnA(b, p[0], p[1]);
        fnA(t, q[0], q[1]);
        fnM(b, b, t);
        fnM(c, p[3], q[3]);
        fnM(c, c, D2);
        fnM(d, p[2], q[2]);
        fnA(d, d, d);
        fnZ(e, b, a);
        fnZ(f, d, c);
        fnA(g, d, c);
        fnA(h, b, a);
        fnM(p[0], e, f);
        fnM(p[1], h, g);
        fnM(p[2], g, f);
        fnM(p[3], e, h);
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} a
     * @param {Float64Array} b
     * @private
     * @internal
     */
    function fnA(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] + b[i];
        }
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} a
     * @param {Float64Array} b
     * @private
     * @internal
     */
    function fnM(o, a, b) {
        var t = new Float64Array(31);
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++) {
                t[i + j] += a[i] * b[j];
            }
        }
        for (var i = 0; i < 15; i++) {
            t[i] += 38 * t[i + 16];
        }
        o.set(t.slice(0, 16));
        car25519(o);
        car25519(o);
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} a
     * @param {Float64Array} b
     * @private
     * @internal
     */
    function fnZ(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] - b[i];
        }
    }
    /**
     * @param {Float64Array} r
     * @param {Float64Array} a
     * @private
     * @internal
     */
    function set25519(r, a) {
        r.set(a);
    }
    /**
     * @param {Float64Array[]} p
     * @param {Uint8Array} s
     * @private
     * @internal
     */
    function scalarbase(p, s) {
        var q = [
            new Float64Array(16), new Float64Array(16),
            new Float64Array(16), new Float64Array(16)
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        fnM(q[3], X, Y);
        scalarmult(p, q, s);
    }
    /**
     * @param {Float64Array} o
     * @private
     * @internal
     */
    function car25519(o) {
        var v;
        var c = 1;
        for (var i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    /**
     * @param {Uint8Array} r
     * @param {Float64Array[]} p
     * @private
     * @internal
     */
    function pack(r, p) {
        var tx = new Float64Array(16);
        var ty = new Float64Array(16);
        var zi = new Float64Array(16);
        inv25519(zi, p[2]);
        fnM(tx, p[0], zi);
        fnM(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    /**
     * @param {Float64Array} a
     * @private
     * @internal
     */
    function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} a
     * @private
     * @internal
     */
    function fnS(o, a) {
        fnM(o, a, a);
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} i
     * @private
     * @internal
     */
    function inv25519(o, i) {
        var c = new Float64Array(16);
        c.set(i);
        for (var a = 253; a >= 0; a--) {
            fnS(c, c);
            if (a !== 2 && a !== 4) {
                fnM(c, c, i);
            }
        }
        o.set(c);
    }
    /**
     * @param {Float64Array} p
     * @param {Float64Array} q
     * @param {number} b
     * @private
     * @internal
     */
    function sel25519(p, q, b) {
        var t;
        var c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    /**
     * @param {Uint8Array} o
     * @param {Float64Array} n
     * @private
     * @internal
     */
    function pack25519(o, n) {
        var b;
        var m = new Float64Array(16);
        var t = new Float64Array(16);
        t.set(n);
        car25519(t);
        car25519(t);
        car25519(t);
        for (var j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed;
            for (var i = 1; i < 15; i++) {
                m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
            b = (m[15] >> 16) & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for (var i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    function secretKeyFromSeed(seed) {
        var pk = new Uint8Array(32);
        var sk = new Uint8Array(64);
        sk.set(seed);
        cryptoSignKeypair(pk, sk);
        return sk;
    }
    function publicKeyFromSecretKey(secretKey) {
        var b = new Uint8Array(32);
        b.set(new Uint8Array(secretKey.buffer, 32, 32));
        return b;
    }
    /**
     * @param {Uint8Array} pk
     * @param {Uint8Array} sk
     * @private
     * @internal
     */
    function cryptoSignKeypair(pk, sk) {
        var p = [
            new Float64Array(16), new Float64Array(16),
            new Float64Array(16), new Float64Array(16)
        ];
        var d = new Uint8Array(sha512(sk.slice(0, 32)));
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        sk.set(pk, 32);
        return 0;
    }
    function sign(message, secretKey) {
        var signedMsg = new Uint8Array(64 + message.length);
        cryptoSign(signedMsg, message, message.length, secretKey);
        return new Uint8Array(signedMsg.buffer, 0, 64);
    }
    /**
     * Note: difference from C - smlen returned, not passed as argument.
     * @param {Uint8Array} sm
     * @param {Uint8Array} m
     * @param {number} n
     * @param {Uint8Array} sk
     * @private
     * @internal
     */
    function cryptoSign(sm, m, n, sk) {
        // const h = new Uint8Array(64)
        // const r = new Uint8Array(64)
        var i;
        var j;
        var x = new Float64Array(64);
        var p = [
            new Float64Array(16),
            new Float64Array(16),
            new Float64Array(16),
            new Float64Array(16)
        ];
        var d = new Uint8Array(sha512(sk.slice(0, 32)));
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        sm.set(m, 64);
        sm.set(d.subarray(32), 32);
        var r = new Uint8Array(sha512(sm.slice(32, 64)));
        // cryptoHash(r, sm.subarray(32), n + 32)
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        sm.set(sk.subarray(32), 32);
        // cryptoHash(h, sm, n + 64)
        var h = new Uint8Array(sha512(sm));
        reduce(h);
        x.set(r);
        for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
                x[i + j] += h[i] * d[j];
            }
        }
        modL(sm.subarray(32), x);
    }
    var D = new Float64Array([
        0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
        0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
    ]);
    var I = new Float64Array([
        0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
        0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
    ]);
    function verify(signature, message, publicKey) {
        var sm = new Uint8Array(64 + message.byteLength);
        var m = new Uint8Array(64 + message.byteLength);
        sm.set(signature);
        sm.set(message, 64);
        m.set(sm);
        return (cryptoSignOpen(m, sm, sm.byteLength, publicKey) >= 0);
    }
    /**
     * @param {Uint8Array} m
     * @param {Uint8Array} sm
     * @param {number} n
     * @param {Uint8Array} pk
     * @private
     * @internal
     */
    function cryptoSignOpen(m, sm, n, pk) {
        var t = new Uint8Array(32);
        var p = [
            new Float64Array(16), new Float64Array(16),
            new Float64Array(16), new Float64Array(16)
        ];
        var q = [
            new Float64Array(16), new Float64Array(16),
            new Float64Array(16), new Float64Array(16)
        ];
        /** @istanbul ignore if */
        if (unpackneg(q, pk)) {
            return -1;
        }
        m.set(sm);
        m.set(pk, 32);
        var h = new Uint8Array(sha512(m));
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        if (cryptoVerify32(sm, t)) {
            return -1;
        }
        return n;
    }
    /**
     * @param {Float64Array[]} r
     * @param {Uint8Array} p
     * @private
     * @internal
     */
    function unpackneg(r, p) {
        var t = new Float64Array(16);
        var chk = new Float64Array(16);
        var num = new Float64Array(16);
        var den = new Float64Array(16);
        var den2 = new Float64Array(16);
        var den4 = new Float64Array(16);
        var den6 = new Float64Array(16);
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        fnS(num, r[1]);
        fnM(den, num, D);
        fnZ(num, num, r[2]);
        fnA(den, r[2], den);
        fnS(den2, den);
        fnS(den4, den2);
        fnM(den6, den4, den2);
        fnM(t, den6, num);
        fnM(t, t, den);
        pow2523(t, t);
        fnM(t, t, num);
        fnM(t, t, den);
        fnM(t, t, den);
        fnM(r[0], t, den);
        fnS(chk, r[0]);
        fnM(chk, chk, den);
        if (neq25519(chk, num)) {
            fnM(r[0], r[0], I);
        }
        fnS(chk, r[0]);
        fnM(chk, chk, den);
        /** @istanbul ignore if */
        if (neq25519(chk, num)) {
            return -1;
        }
        if (par25519(r[0]) === (p[31] >> 7)) {
            fnZ(r[0], gf0, r[0]);
        }
        fnM(r[3], r[0], r[1]);
        return 0;
    }
    /**
     * @param {Uint8Array} x
     * @param {number} xi
     * @param {Uint8Array} y
     * @param {number} yi
     * @private
     * @internal
     */
    function cryptoVerify32(x, y) {
        var d = 0;
        for (var i = 0; i < 32; i++) {
            d |= x[i] ^ y[i];
        }
        return (1 & ((d - 1) >>> 8)) - 1;
    }
    /**
     * @param {Float64Array} o
     * @param {Uint8Array} n
     * @private
     * @internal
     */
    function unpack25519(o, n) {
        for (var i = 0; i < 16; i++) {
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 0x7fff;
    }
    /**
     * @param {Float64Array} o
     * @param {Float64Array} i
     * @private
     * @internal
     */
    function pow2523(o, i) {
        var c = new Float64Array(16);
        c.set(i);
        for (var a = 250; a >= 0; a--) {
            fnS(c, c);
            if (a !== 1) {
                fnM(c, c, i);
            }
        }
        o.set(c);
    }
    /**
     * @param {Float64Array} a
     * @param {Float64Array} b
     * @private
     * @internal
     */
    function neq25519(a, b) {
        var c = new Uint8Array(32);
        var d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return cryptoVerify32(c, d);
    }
    /**
     * Безопасный алгоритм хеширования, SHA2-256.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha256(message) {
        // SHA-256 initial hash values.
        var h = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha256PreProcess(message);
        // Process the message in successive 512-bit chunks / 16 32-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 64; i++) {
                var s0 = rotr(w[i - 15], 7) ^ rotr(w[i - 15], 18) ^ (w[i - 15] >>> 3);
                var s1 = rotr(w[i - 2], 17) ^ rotr(w[i - 2], 19) ^ (w[i - 2] >>> 10);
                w[i] = w[i - 16] + s0 + w[i - 7] + s1;
            }
            // Compression function main loop.
            sha256Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v >>> 24 & 0xff), (v >>> 16 & 0xff), (v >>> 8 & 0xff), (v & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]} message
     * @returns {number[][]}
     */
    function sha256PreProcess(message) {
        var mLen = message.length;
        var bLen = mLen + 8 + (64 - ((mLen + 8) % 64));
        var bytes = [];
        bytes.length = bLen; // Padding
        for (var i = 0; i < bLen; i++) {
            bytes[i] = message[i] || 0;
        }
        bytes[mLen] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 64-bit big-endian integer
        bytes[bLen - 2] = ((mLen * 8) >>> 8) & 0xff;
        bytes[bLen - 1] = (mLen * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytes.length; i < l; i += 64) {
            var chunk = [];
            for (var j = 0; j < 64; j += 4) {
                var n = i + j;
                chunk.push((bytes[n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {number[]} h
     * @param {number[]} w
     */
    function sha256Block(h, w) {
        // SHA-256 round constants.
        var k = [
            0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
            0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
            0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
            0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
            0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
            0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
            0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
            0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
        ];
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = v; // deep copy
        });
        for (var i = 0; i < 64; i++) {
            var S1 = rotr(a[4], 6) ^ rotr(a[4], 11) ^ rotr(a[4], 25);
            var ch = (a[4] & a[5]) ^ ((~a[4]) & a[6]);
            var t1 = a[7] + S1 + ch + k[i] + w[i];
            var S0 = rotr(a[0], 2) ^ rotr(a[0], 13) ^ rotr(a[0], 22);
            var ma = (a[0] & a[1]) ^ (a[0] & a[2]) ^ (a[1] & a[2]);
            var t2 = S0 + ma;
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = a[3] + t1;
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = t1 + t2;
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = h[i] + v | 0; // clamp 32bit
        });
    }
    /**
     * @param {number} n
     * @param {number} i
     * @returns {number}
     */
    function rotr(n, i) {
        return (n >>> i) | (n << (32 - i));
    }
    /**
     * Безопасный алгоритм хеширования, SHA2-512.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha512(message) {
        // SHA-512 initial hash values.
        var h = [
            [0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1],
            [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]
        ];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha512PreProcess(message);
        // Process the message in successive 1024-bit chunks / 16 64-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 80; i++) {
                var s0 = xor64(xor64(rotr64(w[i - 15], 1), rotr64(w[i - 15], 8)), shft64(w[i - 15], 7));
                var s1 = xor64(xor64(rotr64(w[i - 2], 19), rotr64(w[i - 2], 61)), shft64(w[i - 2], 6));
                w[i] = sum64(sum64(w[i - 16], s0), sum64(w[i - 7], s1));
            }
            // Compression function main loop.
            sha512Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v[0] >>> 24 & 0xff), (v[0] >>> 16 & 0xff), (v[0] >>> 8 & 0xff), (v[0] & 0xff));
            digest.push((v[1] >>> 24 & 0xff), (v[1] >>> 16 & 0xff), (v[1] >>> 8 & 0xff), (v[1] & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]} message
     * @returns {[number, number][][]}
     */
    function sha512PreProcess(message) {
        var mLen = message.length;
        var bLen = mLen + 8 + (128 - ((mLen + 8) % 128));
        var bytes = [];
        bytes.length = bLen; // Padding
        for (var i = 0; i < bLen; i++) {
            bytes[i] = message[i] || 0;
        }
        bytes[mLen] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 64-bit big-endian integer
        bytes[bLen - 2] = ((mLen * 8) >>> 8) & 0xff;
        bytes[bLen - 1] = (mLen * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytes.length; i < l; i += 128) {
            var chunk = [];
            for (var j = 0; j < 128; j += 8) {
                var n = i + j;
                chunk.push([
                    (bytes[n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n],
                    (bytes[++n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n]
                ]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {[number, number][]} h
     * @param {[number, number][]} w
     */
    function sha512Block(h, w) {
        // SHA-512 round constants.
        var k = [
            [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc],
            [0x3956c25b, 0xf348b538], [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118],
            [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe], [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2],
            [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235], [0xc19bf174, 0xcf692694],
            [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],
            [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5],
            [0x983e5152, 0xee66dfab], [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4],
            [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725], [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70],
            [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed], [0x53380d13, 0x9d95b3df],
            [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],
            [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30],
            [0xd192e819, 0xd6ef5218], [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8],
            [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53], [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8],
            [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373], [0x682e6ff3, 0xd6b2b8a3],
            [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],
            [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b],
            [0xca273ece, 0xea26619c], [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178],
            [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6], [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b],
            [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc], [0x431d67c4, 0x9c100d4c],
            [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]
        ];
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = [v[0], v[1]]; // deep copy
        });
        // Compression function main loop.
        for (var i = 0; i < 80; i++) {
            var S1 = xor64(xor64(rotr64(a[4], 14), rotr64(a[4], 18)), rotr64(a[4], 41));
            var ch = xor64(and64(a[4], a[5]), and64(not64(a[4]), a[6]));
            var t1 = sum64(sum64(sum64(a[7], S1), sum64(ch, k[i])), w[i]);
            var S0 = xor64(xor64(rotr64(a[0], 28), rotr64(a[0], 34)), rotr64(a[0], 39));
            var ma = xor64(xor64(and64(a[0], a[1]), and64(a[0], a[2])), and64(a[1], a[2]));
            var t2 = sum64(S0, ma);
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = sum64(a[3], t1);
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = sum64(t1, t2);
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = sum64(h[i], v);
        });
    }
    function shft64(n, i) {
        return [(n[0] >>> i), (n[1] >>> i) | (n[0] << (32 - i))];
    }
    function rotr64(n, i) {
        if (i < 32) {
            return [n[0] >>> i | n[1] << (32 - i), n[1] >>> i | n[0] << (32 - i)];
        }
        return [
            n[1] >>> (i - 32) | n[0] << (32 - (i - 32)),
            n[0] >>> (i - 32) | n[1] << (32 - (i - 32))
        ];
    }
    function xor64(a, b) {
        return [(a[0] ^ b[0]), (a[1] ^ b[1])];
    }
    function and64(a, b) {
        return [(a[0] & b[0]), (a[1] & b[1])];
    }
    function not64(n) {
        return [~n[0], ~n[1]];
    }
    /**
     * @param {[number, number]} a
     * @param {[number, number]} b
     * @returns {[number, number]}
     * @private
     * @internal
     */
    function sum64(a, b) {
        var x = [0, 0, 0, 0];
        x[3] = (a[1] & 0xffff) + (b[1] & 0xffff);
        x[2] = (a[1] >>> 16) + (b[1] >>> 16) + (x[3] >>> 16);
        x[1] = (a[0] & 0xffff) + (b[0] & 0xffff) + (x[2] >>> 16);
        x[0] = (a[0] >>> 16) + (b[0] >>> 16) + (x[1] >>> 16);
        return [((x[0] & 0xffff) << 16) + (x[1] & 0xffff), ((x[2] & 0xffff) << 16) + (x[3] & 0xffff)];
    }
    /**
     * Конвертер строки в типизированный массив UTF-8 байтов.
     * @function
     * @param {string} text
     * @returns {Uint8Array}
     * @private
     */
    function Utf8Encode(text) {
        var bytes = [];
        for (var i = 0; i < text.length; i++) {
            var code = text.charCodeAt(i);
            if (code < 0x80) { // ascii
                bytes.push(code);
            }
            else if (code < 0x800) {
                bytes.push(0xc0 | (code >> 6), 0x80 | (code & 0x3f));
            }
            else if (code < 0xd800 || code >= 0xe000) {
                bytes.push((0xe0 | (code >> 12)), (0x80 | ((code >> 6) & 0x3f)));
                bytes.push(0x80 | (code & 0x3f));
            }
            else { // surrogate pair
                code = 0x10000 + ((code & 0x3ff) << 10) + (text.charCodeAt(++i) & 0x3ff);
                bytes.push((0xf0 | (code >> 18)), (0x80 | ((code >> 12) & 0x3f)));
                bytes.push((0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)));
            }
        }
        return new Uint8Array(bytes);
    }
    /**
     * Конвертер из типизированного массива UTF-8 байтов в строку.
     * @function
     * @param {Uint8Array} bytes
     * @returns {string}
     * @private
     */
    function Utf8Decode(bytes) {
        var str = '';
        for (var i = 0; i < bytes.byteLength; i++) {
            if (bytes[i] < 0x80) { // ascii
                str += String.fromCharCode(bytes[i]);
            }
            else if (bytes[i] > 0xBF && bytes[i] < 0xE0) {
                str += String.fromCharCode((bytes[i] & 0x1F) << 6 | bytes[++i] & 0x3F);
            }
            else if (bytes[i] > 0xDF && bytes[i] < 0xF0) {
                str += String.fromCharCode((bytes[i] & 0x0F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F);
            }
            else { // surrogate pair
                var code = ((bytes[i] & 0x07) << 18 | (bytes[++i] & 0x3F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F) - 0x010000;
                str += String.fromCharCode(code >> 10 | 0xD800, code & 0x03FF | 0xDC00);
            }
        }
        return str;
    }
    /**
     * @param {number} arg
     * @param {number} min
     * @param {number} max
     * @throws {Error}
     */
    function validateInt(arg, min, max) {
        if (typeof arg !== 'number') {
            throw new Error('incorrect type');
        }
        if (Math.floor(arg) !== arg) {
            throw new Error('not integer');
        }
        if (arg < min || arg > max) {
            throw new Error('incorrect value');
        }
    }
    /**
     * @param {Uint8Array} arg
     * @param {number} [len]
     */
    function validateUint8Array(arg, len) {
        if (!(arg instanceof Uint8Array)) {
            throw new Error('incorrect type');
        }
        if (len !== undefined && arg.byteLength !== len) {
            throw new Error('incorrect length');
        }
    }
    /**
     * @param {string} arg
     * @param {number} [len]
     */
    function validateStr(arg, len) {
        if (typeof arg !== 'string') {
            throw new Error('incorrect type');
        }
        if (len !== undefined && arg.length !== len) {
            throw new Error('incorrect length');
        }
    }

    exports.Address = Address;
    exports.Block = Block;
    exports.BlockHeader = BlockHeader;
    exports.PublicKey = PublicKey;
    exports.SecretKey = SecretKey;
    exports.Transaction = Transaction;

    return exports;

}({}));
