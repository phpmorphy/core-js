/**
 * @license
 * Copyright (c) 2020 UMI
 * MIT Licensed
 */

var umi = (function (exports) {
    'use strict';

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∞–¥—Ä–µ—Å–∞–º–∏.
     * @class
     */
    var Address = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array} [bytes] –ê–¥—Ä–µ—Å –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, –¥–ª–∏–Ω–∞ 34 –±–∞–π—Ç–∞.
         * @throws {Error}
         */
        function Address(bytes) {
            /**
             * –ê–¥—Ä–µ—Å –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, –¥–ª–∏–Ω–∞ 34 –±–∞–π—Ç–∞.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes === undefined) {
                this.version = Address.Umi;
            }
            else {
                if (bytes.length !== 34) {
                    throw new Error('bytes length must be 34 bytes');
                }
                for (var i = 0; i < 34; i++) {
                    this._bytes[i] = bytes[i];
                }
            }
        }
        Object.defineProperty(Address, "Genesis", {
            /**
             * –í–µ—Ä—Å–∏—è Genesis-–∞–¥—Ä—Å–∞.
             * @type {number}
             * @constant
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address, "Umi", {
            /**
             * –í–µ—Ä—Å–∏—è Umi-–∞–¥—Ä–µ—Å–∞.
             * @type {number}
             * @constant
             */
            get: function () { return 21929; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "bytes", {
            /**
             * –ê–¥—Ä–µ—Å –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, –¥–ª–∏–Ω–∞ 34 –±–∞–π—Ç–∞.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "version", {
            /**
             * –í–µ—Ä—Å–∏—è –∞–¥—Ä–µ—Å–∞, –ø—Ä–µ—Ñ–∏–∫—Å –≤ —á–∏—Å–ª–æ–≤–æ–º –≤–∏–¥–µ.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                // version length = 2
                // version offset = 0
                return (this._bytes[0] << 8) + this._bytes[1];
            },
            set: function (version) {
                versionToPrefix(version); // validation
                // tslint:disable-next-line:no-bitwise
                this._bytes[0] = (version >> 8) & 0xff;
                this._bytes[1] = version & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤–µ—Ä—Å–∏—é –∞–¥—Ä–µ—Å–∞ –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {number} version –í–µ—Ä—Å–∏—è –∞–¥—Ä–µ—Å–∞.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(Address.prototype, "publicKey", {
            /**
             * –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á.
             * @type {PublicKey}
             * @throws {Error}
             */
            get: function () {
                // public key begin = 2
                return new PublicKey(this._bytes.slice(2));
            },
            set: function (publicKey) {
                if (!(publicKey instanceof PublicKey)) {
                    throw new Error('publicKey type must be PublicKey');
                }
                // public key offset = 2
                var b = publicKey.bytes;
                for (var i = 0; i < 32; i++) {
                    this._bytes[2 + i] = b[i];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á–∏ –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {PublicKey} publicKey –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPublicKey = function (publicKey) {
            this.publicKey = publicKey;
            return this;
        };
        Object.defineProperty(Address.prototype, "prefix", {
            /**
             * –ü—Ä–µ—Ñ–∏–∫—Å –∞–¥—Ä–µ—Å–∞, —Ç—Ä–∏ —Å–∏–º–≤–æ–ª–∞ –ª–∞—Ç–∏–Ω–∏—Ü—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return versionToPrefix(this.version);
            },
            set: function (prefix) {
                this.version = prefixToVersion(prefix);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å –∞–¥—Ä–µ—Å–∞ –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {string} prefix –ü—Ä–µ—Ñ–∏–∫—Å –∞–¥—Ä–µ—Å–∞, —Ç—Ä–∏ —Å–∏–º–≤–æ–ª–∞ –ª–∞—Ç–∏–Ω–∏—Ü—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Address.prototype, "bech32", {
            /**
             * –ê–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ Bech32, –¥–ª–∏–Ω–∞ 62 —Å–∏–º–≤–æ–ª–∞.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return encode(this._bytes);
            },
            set: function (bech32) {
                var b = decode(bech32);
                for (var i = 0; i < 32; i++) {
                    this._bytes[i] = b[i];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ Bech32.
         * @param {string} bech32 –ê–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ Bech32, –¥–ª–∏–Ω–∞ 62 —Å–∏–º–≤–æ–ª–∞.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setBech32 = function (bech32) {
            this.bech32 = bech32;
            return this;
        };
        /**
         * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ–∞–±—Ä–∏—á–Ω—ã–π –º–µ—Ç–æ–¥, —Å–æ–∑–¥–∞—é—â–∏–π –æ–±—ä–µ–∫—Ç –∏–∑ –∞–¥—Ä–µ—Å–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Bech32.
         * @param {string} bech32 –ê–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ Bech32, –¥–ª–∏–Ω–∞ 62 —Å–∏–º–≤–æ–ª–∞.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromBech32 = function (bech32) {
            return new Address().setBech32(bech32);
        };
        /**
         * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ–∞–±—Ä–∏—á–Ω—ã–π –º–µ—Ç–æ–¥, —Å–æ–∑–¥–∞—é—â–∏–π –æ–±—ä–µ–∫—Ç –∏–∑ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞.
         * @param {PublicKey|SecretKey} key –ü—É–±–ª–∏—á–Ω—ã–π –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromKey = function (key) {
            if (key instanceof SecretKey) {
                return new Address().setPublicKey(key.publicKey);
            }
            if (key instanceof PublicKey) {
                return new Address().setPublicKey(key);
            }
            throw new Error('key type must be PublicKey or SecretKey');
        };
        return Address;
    }());
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–ª–æ–∫–∞–º–∏.
     * @class
     */
    var Block = /** @class */ (function () {
        function Block() {
        }
        return Block;
    }());
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –±–ª–æ–∫–æ–≤.
     * @class
     */
    var BlockHeader = /** @class */ (function () {
        function BlockHeader() {
        }
        return BlockHeader;
    }());
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—É–±–ª–∏—á–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏.
     * @class
     */
    var PublicKey = /** @class */ (function () {
        /**
         * @param {number[]} bytes –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ —Ñ–æ—Ä–º–∞—Ç–µ libsodium, 32 –±–∞–π—Ç–∞ (256 –±–∏—Ç).
         * @throws {Error}
         */
        function PublicKey(bytes) {
            /**
             * –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ. –í —Ñ–æ—Ä–º–∞—Ç–µ libsodium.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes.length !== 32) {
                throw new Error('invalid length');
            }
            for (var i = 0; i < 32; i++) {
                this._bytes[i] = bytes[i];
            }
        }
        Object.defineProperty(PublicKey, "LENGTH", {
            /**
             * –î–ª–∏–Ω–∞ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ libsodium –≤ –±–∞–π—Ç–∞—Ö.
             * @type {number}
             * @constant
             */
            get: function () { return 32; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey, "SIGNATURE_LENGTH", {
            /**
             * –î–ª–∏–Ω–∞ —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∏ –≤ –±–∞–π—Ç–∞—Ö.
             * @type {number}
             * @constant
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "signatureLength", {
            /**
             * –î–ª–∏–Ω–∞ —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∏ –≤ –±–∞–π—Ç–∞—Ö.
             * @type {number}
             * @constant
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "bytes", {
            /**
             * –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ —Ñ–æ—Ä–º–∞—Ç–µ libsodium, 32 –±–∞–π—Ç–∞ (256 –±–∏—Ç).
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0, 32);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ü–∏—Ñ—Ä–æ–≤—É—é –ø–æ–¥–ø–∏—Å—å.
         * @param {number[]|Uint8Array|Buffer} signature –ü–æ–¥–ø–∏—Å—å, 64 –±–∞–π—Ç–∞.
         * @param {number[]|Uint8Array|Buffer} message –°–æ–æ–±—â–µ–Ω–∏–µ
         * @returns {boolean}
         * @throws {Error}
         * @example
         * let key = new Uint8Array(32)
         * let sig = new Uint8Array(64)
         * let msg = new Uint8Array(1)
         * let ver = new PublicKey(key).verifySignature(sig, msg)
         */
        PublicKey.prototype.verifySignature = function (signature, message) {
            if (signature.length !== 64) {
                throw new Error('invalid length');
            }
            return verify(signature, message, this._bytes);
        };
        return PublicKey;
    }());
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏.
     * @class
     */
    var SecretKey = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array|Buffer} bytes –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ.
         * –í —Ñ–æ—Ä–º–∞—Ç–µ libsodium, 64 –±–∞–π—Ç–∞ (512 –±–∏—Ç).
         * @throws {Error}
         */
        function SecretKey(bytes) {
            /**
             * –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ. –í —Ñ–æ—Ä–º–∞—Ç–µ libsodium.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes.length !== 64) {
                throw new Error('invalid length');
            }
            for (var i = 0; i < 64; i++) {
                this._bytes[i] = bytes[i];
            }
        }
        Object.defineProperty(SecretKey, "LENGTH", {
            /**
             * –î–ª–∏–Ω–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ libsodium –≤ –±–∞–π—Ç–∞—Ö.
             * @type {number}
             * @internal
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "bytes", {
            /**
             * –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ. –í —Ñ–æ—Ä–º–∞—Ç–µ libsodium, 64 –±–∞–π—Ç–∞ (512 –±–∏—Ç).
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0, 64);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "publicKey", {
            /**
             * –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ø—Ä–∏–≤–∞—Ç–Ω–æ–º—É –∫–ª—é—á—É.
             * @type {PublicKey}
             * @readonly
             */
            get: function () {
                return new PublicKey(this._bytes.slice(32, 64));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –°–æ–∑–¥–∞–µ—Ç —Ü–∏—Ñ—Ä–æ–≤—É—é –ø–æ–¥–ø–∏—Å—å —Å–æ–æ–±—â–µ–Ω–∏—è.
         * @param {number[]|Uint8Array|Buffer} message –°–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å.
         * @returns {number[]} –¶–∏—Ñ—Ä–æ–≤–∞—è –ø–æ–¥–ø–∏—Å—å –¥–ª–∏–Ω–æ–π 64 –±–∞–π—Ç–∞ (512 –±–∏—Ç).
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let msg = new Uint8Array(1)
         * let sig = SecretKey.fromSeed(seed).sign(msg)
         */
        SecretKey.prototype.sign = function (message) {
            return sign(message, this._bytes);
        };
        /**
         * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ–∞–±—Ä–∏—á–Ω—ã–π –º–µ—Ç–æ–¥, —Å–æ–∑–¥–∞—é—â–∏–π –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∏–∑ seed.
         * Libsodium –ø—Ä–∏–Ω–∏–º–∞–µ—Ç seed –¥–ª–∏–Ω–æ–π 32 –±–∞–π—Ç–∞ (256 –±–∏—Ç), –µ—Å–ª–∏ –¥–ª–∏–Ω–∞
         * –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è, —Ç–æ –±–µ—Ä–µ—Ç—Å—è sha256 —Ö—ç—à.
         * @param {number[]|Uint8Array|Buffer} seed Seed –¥–ª–∏–Ω–æ–π –æ—Ç 0 –¥–æ 128 –±–∞–π—Ç.
         * @returns {SecretKey}
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let key = SecretKey.fromSeed(seed)
         */
        SecretKey.fromSeed = function (seed) {
            var entropy = seed;
            if (seed.length !== 32) {
                entropy = sha256(entropy);
            }
            return new SecretKey(secretKeyFromSeed(entropy));
        };
        return SecretKey;
    }());
    /**
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransaction = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array|Buffer} [bytes] –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, 150 –±–∞–π—Ç.
         * @throws {Error}
         * @private
         */
        function AbstractTransaction(bytes) {
            /**
             * –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            /**
             * –ó–∞–ø–æ–ª–æ–Ω–µ–Ω–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞.
             * @type {Object}
             * @private
             * @internal
             */
            this._fieldsMap = {};
            arrayFill(this._bytes, 150);
            if (bytes !== undefined) {
                if (bytes.length !== 150) {
                    throw new Error('incorrect length');
                }
                arraySet(this._bytes, bytes);
                this._setFields([
                    'version', 'sender', 'recipient', 'value', 'prefix',
                    'name', 'profitPercent', 'feePercent', 'nonce', 'signature'
                ]);
            }
        }
        Object.defineProperty(AbstractTransaction, "Genesis", {
            /**
             * Genesis-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è.
             * –ú–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ Genesis-–±–ª–æ–∫.
             * –ê–¥—Ä–µ—Å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å genesis, –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞–µ—Ç–µ–ª—è - umi.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('genesis')
             * let recipient = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.Genesis).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "Basic", {
            /**
             * –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è. –ü–µ—Ä–µ–≤–æ–¥ –º–æ–Ω–µ—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ –∫–æ—à–µ–ª—å–∫–∞ –≤ –¥—Ä—É–≥–æ–π.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let recipient = Address.fromKey(secKey).setPrefix('aaa')
             * let tx = new Transaction().
             *   setVersion(Transaction.Basic).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateStructure", {
            /**
             * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('üôÇ').
             *   setProfitPercent(100).
             *   setFeePercent(0).
             *   sign(secKey)
             */
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateStructure", {
            /**
             * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('üôÇ').
             *   setProfitPercent(500).
             *   setFeePercent(2000).
             *   sign(secKey)
             */
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateProfitAddress", {
            /**
             * –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –¥–ª—è –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏—Ç–∞.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newPrf = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateProfitAddress).
             *   setSender(sender).
             *   setRecipient(newPrf).
             *   sign(secKey)
             */
            get: function () { return 4; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateFeeAddress", {
            /**
             * –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥–æ–∏—Ç—Å—è –∫–æ–º–∏—Å—Å–∏—è.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newFee = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateFeeAddress).
             *   setSender(sender).
             *   setRecipient(newFee).
             *   sign(secKey)
             */
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateTransitAddress", {
            /**
             * –ê–∫—Ç–∏–≤–∞—Ü–∏—è —Ç—Ä–∞–Ω–∑–∏—Ç–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 6; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "DeleteTransitAddress", {
            /**
             * –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è —Ç—Ä–∞–Ω–∑–∏—Ç–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.DeleteTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 7; },
            enumerable: false,
            configurable: true
        });
        /**
         * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞.
         * @param {string[]} fields
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransaction.prototype._checkFields = function (fields) {
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var field = fields_1[_i];
                if (!Object.prototype.hasOwnProperty.call(this._fieldsMap, field)) {
                    throw new Error(field + " must be set");
                }
            }
        };
        /**
         * –û—Ç–º–µ—Ç–∏—Ç—å —Å–≤–æ–π—Å—Ç–≤–æ –∫–∞–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ.
         * @param {string[]} fields
         * @private
         * @internal
         */
        AbstractTransaction.prototype._setFields = function (fields) {
            for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
                var field = fields_2[_i];
                this._fieldsMap[field] = true;
            }
        };
        return AbstractTransaction;
    }());
    /**
     * –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏.
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransactionBase = /** @class */ (function (_super) {
        __extends(AbstractTransactionBase, _super);
        function AbstractTransactionBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AbstractTransactionBase.prototype, "bytes", {
            /**
             * –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, 150 –±–∞–π—Ç.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "hash", {
            /**
             * –•—ç—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, sha256 –æ—Ç –≤—Å–µ—Ö 150 –±–∞–π—Ç.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return sha256(this._bytes);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "version", {
            /**
             * –í–µ—Ä—Å–∏—è (—Ç–∏–ø) —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏.
             * –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–¥–∞—Ç—å —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏.
             * –ò–∑–º–µ–Ω—è—Ç—å —Ç–∏–ø —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –æ–Ω –±—ã–ª –∑–∞–¥–∞–Ω, –Ω–µ–ª—å–∑—è.
             * @type {number}
             * @throws {Error}
             * @see Transaction.Genesis
             * @see Transaction.Basic
             * @see Transaction.CreateStructure
             * @see Transaction.UpdateStructure
             * @see Transaction.UpdateProfitAddress
             * @see Transaction.UpdateFeeAddress
             * @see Transaction.CreateTransitAddress
             * @see Transaction.DeleteTransitAddress
             */
            get: function () {
                this._checkFields(['version']);
                return this._bytes[0];
            },
            set: function (version) {
                if (Object.prototype.hasOwnProperty.call(this._fieldsMap, 'version')) {
                    throw new Error('could not update version');
                }
                validateInt(version, 0, 7);
                this._bytes[0] = version;
                this._setFields(['version']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤–µ—Ä—Å–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {number} version –í–µ—Ä—Å–∏—è –∞–¥—Ä–µ—Å–∞.
         * @returns {this}
         * @throws {Error}
         * @see Transaction.Genesis
         * @see Transaction.Basic
         * @see Transaction.CreateStructure
         * @see Transaction.UpdateStructure
         * @see Transaction.UpdateProfitAddress
         * @see Transaction.UpdateFeeAddress
         * @see Transaction.CreateTransitAddress
         * @see Transaction.DeleteTransitAddress
         */
        AbstractTransactionBase.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "sender", {
            /**
             * –û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å. –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['sender']);
                // sender length = 34
                // sender begin = 1
                // sender end = 35
                return new Address(this._bytes.slice(1, 35));
            },
            set: function (address) {
                this._checkFields(['version']);
                if (!(address instanceof Address)) {
                    throw new Error('address type must be Address');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Genesis) {
                    throw new Error('address version must be genesis');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    address.version === Address.Genesis) {
                    throw new Error('address version must not be genesis');
                }
                // sender offset = 1
                arraySet(this._bytes, address.bytes, 1);
                this._setFields(['sender']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {Address} address –ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSender = function (address) {
            this.sender = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "recipient", {
            /**
             * –ü–æ–ª—É—á–∞—Ç–µ–ª—å.
             * –ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π CreateStructure –∏ UpdateStructure.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                this._checkFields(['recipient']);
                // recipient begin = 35
                // recipient end = 69
                return new Address(this._bytes.slice(35, 69));
            },
            set: function (address) {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                if (!(address instanceof Address)) {
                    throw new Error('recipient type must be Address');
                }
                if (address.version === Address.Genesis) {
                    throw new Error('recipient version must not be genesis');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Umi) {
                    throw new Error('recipient version must be umi');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    this.version !== AbstractTransactionBase.Basic &&
                    address.version === Address.Umi) {
                    throw new Error('recipient version must not be umi');
                }
                // recipient offset = 35
                arraySet(this._bytes, address.bytes, 35);
                this._setFields(['recipient']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–æ–ª—É—á–∞—Ç–µ–ª—è –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –∫—Ä–æ–º–µ CreateStructure –∏ UpdateStructure.
         * @param {Address} address –ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setRecipient = function (address) {
            this.recipient = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "value", {
            /**
             * –°—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ –≤ UMI-—Ü–µ–Ω—Ç–∞—Ö, —Ü–µ–ª–æ —á–∏—Å–ª–æ –≤ –ø—Ä–æ–º–µ–∂—É—Ç–∫–µ –æ—Ç 1 –¥–æ 18446744073709551615.
             * –ò–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π JavaScript –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ 9007199254740991.
             * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è Genesis –∏ Basic —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                this._checkFields(['value']);
                // value offset = 69
                return bytesToUint64(this._bytes.slice(69, 76));
            },
            set: function (value) {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                validateInt(value, 1, 9007199254740991);
                // value offset = 69
                arraySet(this._bytes, uint64ToBytes(value), 69);
                this._setFields(['value']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å—É–º–º—É –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø—Ä–æ–º–µ–∂—É—Ç–∫–µ –æ—Ç 1 –¥–æ 9007199254740991.
         * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è Genesis –∏ Basic —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π.
         * @param {number} value
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setValue = function (value) {
            this.value = value;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "nonce", {
            /**
             * Nonce, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –≤ –ø—Ä–æ–º–µ–∂—É—Ç–∫–µ –æ—Ç 0 –¥–æ 18446744073709551615.
             * –ò–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π JavaScript –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ 9007199254740991.
             * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ–∫–∏ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ sign().
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['nonce']);
                // nonce offset = 77
                return bytesToUint64(this._bytes.slice(77, 85));
            },
            set: function (nonce) {
                validateInt(nonce, 0, 9007199254740991);
                // nonce offset = 77
                arraySet(this._bytes, uint64ToBytes(nonce), 77);
                this._setFields(['nonce']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç nonce –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {number} nonce Nonce, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ–≤ –ø—Ä–æ–º–µ–∂—É—Ç–∫–µ –æ—Ç 0 –¥–æ 9007199254740991.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setNonce = function (nonce) {
            this.nonce = nonce;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "signature", {
            /**
             * –¶–∏—Ñ—Ä–æ–≤–∞—è –ø–æ–¥–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, –¥–ª–∏–Ω–∞ 64 –±–∞–π—Ç–∞.
             * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ sign().
             * @type {number[]}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['signature']);
                // signature length = 64
                var len = this.sender.publicKey.signatureLength;
                // signature offset = 85
                return this._bytes.slice(85, 85 + len);
            },
            set: function (signature) {
                this._checkFields(['version', 'sender']);
                if (signature.length !== this.sender.publicKey.signatureLength) {
                    throw new Error('invalid length');
                }
                // signature offset = 85
                arraySet(this._bytes, signature, 85);
                this._setFields(['signature']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ü–∏—Ñ—Ä–æ–≤—É—é –ø–æ–¥–ø–∏—Å—å –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * @param {number[]|Uint8Array|Buffer} signature –ü–æ–¥–ø–∏—Å—å, –¥–ª–∏–Ω–∞ 64 –±–∞–π—Ç–∞.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSignature = function (signature) {
            this.signature = signature;
            return this;
        };
        /**
         * –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –∫–ª—é—á–µ–º.
         * @param {SecretKey} secretKey
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.sign = function (secretKey) {
            this._checkFields(['version', 'sender']);
            if (!(secretKey instanceof SecretKey)) {
                throw new Error('secretKey type must be SecretKey');
            }
            // unsigned begin = 0
            // unsigned end = 85
            this.signature = secretKey.sign(this._bytes.slice(0, 85));
            return this;
        };
        /**
         * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –Ω–∞ —Å–æ–æ—Ç–≤–µ—Å—Ç–≤–∏–µ —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –ø—Ä–∞–≤–∏–ª–∞–º.
         * @returns {boolean}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.verify = function () {
            this._checkFields(['version', 'sender', 'signature']);
            // unsigned begin = 0
            // unsigned end = 85
            return this.sender.publicKey.verifySignature(this.signature, this._bytes.slice(0, 85));
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsBasic = function () {
            var versions = [AbstractTransaction.Genesis, AbstractTransaction.Basic];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsNotStruct = function () {
            var versions = [AbstractTransaction.CreateStructure, AbstractTransaction.UpdateStructure];
            if (versions.indexOf(this.version) !== -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        return AbstractTransactionBase;
    }(AbstractTransaction));
    /**
     * –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏.
     * @class
     * @param {number[]} [bytes] –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –≤–∏–¥–µ, 150 –±–∞–π—Ç.
     * @throws {Error}
     */
    var Transaction = /** @class */ (function (_super) {
        __extends(Transaction, _super);
        function Transaction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        Transaction.prototype._checkVersionIsStruct = function () {
            var versions = [Transaction.CreateStructure, Transaction.UpdateStructure];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        Object.defineProperty(Transaction.prototype, "prefix", {
            /**
             * –ü—Ä–µ—Ñ–∏–∫—Å –∞–¥—Ä–µ—Å–æ–≤, –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—â–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–µ.
             * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['prefix']);
                // prefix offset = 35
                var ver = (this._bytes[35] << 8) + this._bytes[36];
                return versionToPrefix(ver);
            },
            set: function (prefix) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                var ver = prefixToVersion(prefix);
                // prefix offset = 35
                this._bytes[35] = (ver >>> 8) & 0xff;
                this._bytes[36] = ver & 0xff;
                this._setFields(['prefix']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
         * @param {string} prefix –ü—Ä–µ—Ñ–∏–∫—Å –∞–¥—Ä–µ—Å–æ–≤, –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—â–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–µ.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "name", {
            /**
             * –ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.
             * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['name']);
                // name offset = 41
                var txt = this._bytes.slice(42, 42 + this._bytes[41]);
                return Utf8Decode(txt);
            },
            set: function (name) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                if (typeof name !== 'string') {
                    throw new Error('name type must be a string');
                }
                var txt = Utf8Encode(name);
                if (txt.length >= 36) {
                    throw new Error('name is too long');
                }
                // name length = 36
                // name offset = 41
                this._bytes[41] = txt.length;
                for (var i = 0; i < 35; i++) {
                    this._bytes[42 + i] = txt[i] || 0;
                }
                this._setFields(['name']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
         * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
         * @param {string} name –ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setName = function (name) {
            this.name = name;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "profitPercent", {
            /**
             * –ü—Ä–æ—Ñ–∏—Ç–∞ –≤ —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —Å —à–∞–≥–æ–º –≤ 0.01%.
             * –í–∞–ª–∏–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 100 –¥–æ 500 (—Å–æ–æ—Ç–≤–µ—Å—Ç–≤–µ–Ω–Ω–æ –æ—Ç 1% –¥–æ 5%).
             * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['profitPercent']);
                // profit offset = 37
                return (this._bytes[37] << 8) + this._bytes[38];
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 100, 500);
                // profit offset = 37
                this._bytes[37] = (percent >>> 8) & 0xff;
                this._bytes[38] = percent & 0xff;
                this._setFields(['profitPercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–æ—Ñ–∏—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—â—è–µ—Ç this.
         * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
         * @param {number} percent –ü—Ä–æ—Ñ–∏—Ç –≤ —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —Å —à–∞–≥–æ–º –≤ 0.01%. –í–∞–ª–∏–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 100 –¥–æ 500 (—Å–æ–æ—Ç–≤–µ—Å—Ç–≤–µ–Ω–Ω–æ –æ—Ç 1% –¥–æ 5%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setProfitPercent = function (percent) {
            this.profitPercent = percent;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "feePercent", {
            /**
             * –ö–æ–º–∏—Å—Å–∏—è –≤ —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —Å —à–∞–≥–æ–º –≤ 0.01%.
             * –í–∞–ª–∏–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 0 –¥–æ 2000 (—Å–æ–æ—Ç–≤–µ—Å—Ç–≤–µ–Ω–Ω–æ –æ—Ç 0% –¥–æ 20%).
             * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['feePercent']);
                // fee offset = 39
                return (this._bytes[39] << 8) + this._bytes[40];
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 0, 2000);
                // fee offset = 39
                this._bytes[39] = (percent >>> 8) & 0xff;
                this._bytes[40] = percent & 0xff;
                this._setFields(['feePercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –∫–æ–º–∏—Å—Å–∏–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç this.
         * –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è CreateStructure –∏ UpdateStructure.
         * @param {number} percent –ö–æ–º–∏—Å—Å–∏—è –≤ —Å–æ—Ç—ã—Ö –¥–æ–ª—è—Ö –ø—Ä–æ—Ü–µ–Ω—Ç–∞ —Å —à–∞–≥–æ–º –≤ 0.01%. –í–∞–ª–∏–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 0 –¥–æ 2000 (—Å–æ–æ—Ç–≤–µ—Å—Ç–≤–µ–Ω–Ω–æ –æ—Ç 0% –¥–æ 20%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setFeePercent = function (percent) {
            this.feePercent = percent;
            return this;
        };
        return Transaction;
    }(AbstractTransactionBase));
    /**
     * @param {number[]} array
     * @param {number} [length]
     * @param [value]
     */
    function arrayFill(array, length, value) {
        var v = value || 0;
        for (var i = 0; i < length; i++) {
            array[i] = v;
        }
    }
    /**
     * @param {number[]} a
     * @param {number[]} b
     * @param {number} offset
     * @param {number} length
     */
    function arraySet(a, b, offset, length) {
        var o = offset || 0;
        var l = length || b.length;
        for (var i = 0; i < l; i++) {
            a[o + i] = b[i];
        }
    }
    var alphabet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
    /**
     * @param {number[]|Uint8Array|Buffer} bytes
     * @returns {string}
     */
    function encode(bytes) {
        var version = (bytes[0] << 8) + bytes[1];
        var prefix = versionToPrefix(version);
        var data = convert8to5(bytes.slice(2));
        var checksum = createChecksum(prefix, data);
        return prefix + '1' + data + checksum;
    }
    /**
     * @param {string} bech32
     * @returns {number[]}
     */
    function decode(bech32) {
        if (bech32.length !== 62 && bech32.length !== 66) {
            throw new Error('bech32: invalid length');
        }
        var str = bech32.toLowerCase();
        var sepPos = str.lastIndexOf('1');
        if (sepPos === -1) {
            throw new Error('bech32: missing separator');
        }
        var pfx = str.slice(0, sepPos);
        var ver = prefixToVersion(pfx);
        var data = str.slice(sepPos + 1);
        checkAlphabet(data);
        verifyChecksum(pfx, data);
        var res = [];
        res[0] = (ver >>> 8) & 0xff;
        res[1] = ver & 0xff;
        return res.concat(convert5to8(data.slice(0, -6)));
    }
    function convert5to8(data) {
        var value = 0;
        var bits = 0;
        var bytes = strToBytes(data);
        var result = [];
        for (var i = 0; i < bytes.length; i++) {
            value = (value << 5) | bytes[i];
            bits += 5;
            while (bits >= 8) {
                bits -= 8;
                result.push((value >> bits) & 0xff);
            }
        }
        if ((bits >= 5) || (value << (8 - bits)) & 0xff) {
            throw new Error('bech32: invalid data');
        }
        return result;
    }
    function convert8to5(data) {
        var value = 0;
        var bits = 0;
        var result = '';
        for (var i = 0; i < data.length; i++) {
            value = (value << 8) | data[i];
            bits += 8;
            while (bits >= 5) {
                bits -= 5;
                result += alphabet[(value >> bits) & 0x1f];
            }
        }
        /** @istanbul ignore else */
        if (bits > 0) {
            result += alphabet[(value << (5 - bits)) & 0x1f];
        }
        return result;
    }
    function createChecksum(prefix, data) {
        var bytes = strToBytes(data);
        var pfx = prefixExpand(prefix);
        var values = new Uint8Array(pfx.length + bytes.length + 6);
        values.set(pfx);
        values.set(bytes, pfx.length);
        var poly = polyMod(values) ^ 1;
        var checksum = '';
        for (var i = 0; i < 6; i++) {
            checksum += alphabet[(poly >> 5 * (5 - i)) & 31];
        }
        return checksum;
    }
    function polyMod(values) {
        var gen = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
        var chk = 1;
        for (var i = 0; i < values.length; i++) {
            var top_1 = chk >> 25;
            chk = (chk & 0x1ffffff) << 5 ^ values[i];
            for (var j = 0; j < 5; j++) {
                chk ^= ((top_1 >> j) & 1)
                    ? gen[j]
                    : 0;
            }
        }
        return chk;
    }
    function prefixExpand(prefix) {
        var res = [];
        res[prefix.length] = 0;
        for (var i = 0; i < prefix.length; i++) {
            var ord = prefix.charCodeAt(i);
            res[i] = ord >> 5;
            res[i + prefix.length + 1] = ord & 31;
        }
        return res;
    }
    function strToBytes(str) {
        var bytes = [];
        for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
            var chr = str_1[_i];
            bytes.push(alphabet.indexOf(chr));
        }
        return bytes;
    }
    function verifyChecksum(prefix, data) {
        var pfx = prefixExpand(prefix);
        var bytes = strToBytes(data);
        var values = new Uint8Array(pfx.length + bytes.length);
        values.set(pfx);
        values.set(bytes, pfx.length);
        var poly = polyMod(values);
        if (poly !== 1) {
            throw new Error('bech32: invalid checksum');
        }
    }
    function checkAlphabet(chars) {
        for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {
            var chr = chars_1[_i];
            if (alphabet.indexOf(chr) === -1) {
                throw new Error('bech32: invalid character');
            }
        }
    }
    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Ü–∏—Ñ—Ä–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ.
     * @param {number} version
     * @returns {string}
     * @throws {Error}
     * @private
     */
    function versionToPrefix(version) {
        validateInt(version, 0, 65535);
        if (version === 0) {
            return 'genesis';
        }
        if ((version & 0x8000) === 0x8000) {
            throw new Error('bech32: incorrect version');
        }
        var a = (version & 0x7C00) >> 10;
        var b = (version & 0x03E0) >> 5;
        var c = (version & 0x001F);
        checkChars([a, b, c]);
        return String.fromCharCode((a + 96), (b + 96), (c + 96));
    }
    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Ç–µ–∫—Å—Ç–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ –ø—Ä–µ—Ñ–∏–∫—Å–∞ –≤ —á–∏—Å–ª–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ.
     * @param {string} prefix
     * @returns {number}
     * @throws {Error}
     * @private
     */
    function prefixToVersion(prefix) {
        if (prefix === 'genesis') {
            return 0;
        }
        validateStr(prefix, 3);
        var a = prefix.charCodeAt(0) - 96;
        var b = prefix.charCodeAt(1) - 96;
        var c = prefix.charCodeAt(2) - 96;
        checkChars([a, b, c]);
        return (a << 10) + (b << 5) + c;
    }
    /**
     * @param {number[]} chars
     * @throws {Error}
     */
    function checkChars(chars) {
        for (var _i = 0, chars_2 = chars; _i < chars_2.length; _i++) {
            var chr = chars_2[_i];
            if (chr < 1 || chr > 26) {
                throw new Error('bech32: incorrect prefix character');
            }
        }
    }
    var gf0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var gf1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var D2 = [
        0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
        0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
    ];
    var X = [
        0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
        0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
    ];
    var Y = [
        0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
        0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
    ];
    var L = [
        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
        0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
    ];
    /**
     * @param {number[]} r
     * @private
     * @internal
     */
    function reduce(r) {
        var x = r.slice(0);
        arrayFill(r, 64);
        modL(r, x);
    }
    /**
     * @param {number[]} r
     * @param {number[]} x
     * @private
     * @internal
     */
    function modL(r, x) {
        var carry;
        var j;
        var k;
        for (var i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256); // carry = (x[j] + 128) >> 8;
                x[j] -= carry * 256; // x[j] -= carry << 8;
            }
            x[j] += carry;
            x[i] = 0;
        }
        return modLSub(r, x);
    }
    function modLSub(r, x) {
        var carry = 0;
        for (var j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for (var j = 0; j < 32; j++) {
            x[j] -= carry * L[j];
        }
        for (var i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
        return r;
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @param {number[]} s
     * @private
     * @internal
     */
    function scalarmult(p, q, s) {
        arraySet(p[0], gf0);
        arraySet(p[1], gf1);
        arraySet(p[2], gf1);
        arraySet(p[3], gf0);
        for (var i = 255; i >= 0; --i) {
            var b = (s[(i / 8) | 0] >> (i & 7)) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @param {number} b
     * @private
     * @internal
     */
    function cswap(p, q, b) {
        for (var i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @private
     * @internal
     */
    function add(p, q) {
        var a = [];
        var b = [];
        var c = [];
        var d = [];
        var e = [];
        var f = [];
        var g = [];
        var h = [];
        var t = [];
        fnZ(a, p[1], p[0]);
        fnZ(t, q[1], q[0]);
        fnM(a, a, t);
        fnA(b, p[0], p[1]);
        fnA(t, q[0], q[1]);
        fnM(b, b, t);
        fnM(c, p[3], q[3]);
        fnM(c, c, D2);
        fnM(d, p[2], q[2]);
        fnA(d, d, d);
        fnZ(e, b, a);
        fnZ(f, d, c);
        fnA(g, d, c);
        fnA(h, b, a);
        fnM(p[0], e, f);
        fnM(p[1], h, g);
        fnM(p[2], g, f);
        fnM(p[3], e, h);
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnA(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] + b[i];
        }
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnM(o, a, b) {
        var t = [];
        arrayFill(t, 31);
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++) {
                t[i + j] += a[i] * b[j];
            }
        }
        for (var i = 0; i < 15; i++) {
            t[i] += 38 * t[i + 16];
        }
        arraySet(o, t, 0, 16);
        car25519(o);
        car25519(o);
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnZ(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] - b[i];
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[]} s
     * @private
     * @internal
     */
    function scalarbase(p, s) {
        var q = [[], [], [], []];
        arraySet(q[0], X);
        arraySet(q[1], Y);
        arraySet(q[2], gf1);
        fnM(q[3], X, Y);
        scalarmult(p, q, s);
    }
    /**
     * @param {number[]} o
     * @private
     * @internal
     */
    function car25519(o) {
        var v;
        var c = 1;
        for (var i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    /**
     * @param {number[]} r
     * @param {number[][]} p
     * @private
     * @internal
     */
    function pack(r, p) {
        var tx = [];
        var ty = [];
        var zi = [];
        inv25519(zi, p[2]);
        fnM(tx, p[0], zi);
        fnM(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    /**
     * @param {number[]} a
     * @returns {number}
     * @private
     * @internal
     */
    function par25519(a) {
        var d = [];
        pack25519(d, a);
        return d[0] & 1;
    }
    /**
     * @param {number[]} o
     * @param {number[]} i
     * @private
     * @internal
     */
    function inv25519(o, i) {
        var c = [];
        arraySet(c, i);
        for (var a = 253; a >= 0; a--) {
            fnM(c, c, c);
            if (a !== 2 && a !== 4) {
                fnM(c, c, i);
            }
        }
        arraySet(o, c);
    }
    /**
     * @param {number[]} p
     * @param {number[]} q
     * @param {number} b
     * @private
     * @internal
     */
    function sel25519(p, q, b) {
        var c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
            var t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    /**
     * @param {number[]} o
     * @param {number[]} n
     * @private
     * @internal
     */
    function pack25519(o, n) {
        var m = [];
        var t = n.slice(0);
        car25519(t);
        car25519(t);
        car25519(t);
        for (var j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed;
            for (var i = 1; i < 15; i++) {
                m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
            var b = (m[15] >> 16) & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for (var i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    var D = [
        0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
        0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
    ];
    var I = [
        0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
        0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
    ];
    /**
     * Note: difference from C - smlen returned, not passed as argument.
     * @param {number[]|Uint8Array|Buffer} message
     * @param {number[]|Uint8Array|Buffer} secretKey
     * @returns {number[]}
     * @private
     * @internal
     */
    function sign(message, secretKey) {
        var d = sha512(secretKey.slice(0, 32));
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var sm = d.slice(0);
        arraySet(sm, message, 64);
        var r = sha512(sm.slice(32));
        reduce(r);
        var p = [[], [], [], []];
        scalarbase(p, r);
        pack(sm, p);
        arraySet(sm, secretKey.slice(32), 32);
        var h = sha512(sm);
        reduce(h);
        for (var i = 0; i < 32; i++) {
            for (var j = 0; j < 32; j++) {
                r[i + j] += h[i] * d[j];
            }
        }
        return sm.slice(0, 32).concat(modL(sm.slice(32), r).slice(0, 32));
    }
    /**
     * @param {number[]|Uint8Array|Buffer} signature
     * @param {number[]|Uint8Array|Buffer} message
     * @param {number[]|Uint8Array|Buffer} pubKey
     * @returns {boolean}
     * @private
     * @internal
     */
    function verify(signature, message, pubKey) {
        var sm = [];
        var t = [];
        var p = [[], [], [], []];
        var q = [[], [], [], []];
        /** @istanbul ignore if */
        if (!unpackneg(q, pubKey)) {
            return false;
        }
        arraySet(sm, signature, 0);
        arraySet(sm, message, 64);
        var m = sm.slice(0);
        arraySet(m, pubKey, 32);
        var h = sha512(m);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.slice(32));
        add(p, q);
        pack(t, p);
        return cryptoVerify32(sm, t);
    }
    /**
     * @param {number[][]} r
     * @param {number[]|Uint8Array} p
     * @returns {boolean}
     * @private
     * @internal
     */
    function unpackneg(r, p) {
        var t = [];
        var chk = [];
        var num = [];
        var den = [];
        var den2 = [];
        var den4 = [];
        var den6 = [];
        arraySet(r[2], gf1);
        unpack25519(r[1], p);
        fnM(num, r[1], r[1]);
        fnM(den, num, D);
        fnZ(num, num, r[2]);
        fnA(den, r[2], den);
        fnM(den2, den, den);
        fnM(den4, den2, den2);
        fnM(den6, den4, den2);
        fnM(t, den6, num);
        fnM(t, t, den);
        pow2523(t, t);
        fnM(t, t, num);
        fnM(t, t, den);
        fnM(t, t, den);
        fnM(r[0], t, den);
        fnM(chk, r[0], r[0]);
        fnM(chk, chk, den);
        if (!neq25519(chk, num)) {
            fnM(r[0], r[0], I);
        }
        fnM(chk, r[0], r[0]);
        fnM(chk, chk, den);
        /** @istanbul ignore if */
        if (!neq25519(chk, num)) {
            return false;
        }
        if (par25519(r[0]) === (p[31] >> 7)) {
            fnZ(r[0], gf0, r[0]);
        }
        fnM(r[3], r[0], r[1]);
        return true;
    }
    /**
     * @param {number[]} x
     * @param {number[]} y
     * @returns {boolean}
     * @private
     * @internal
     */
    function cryptoVerify32(x, y) {
        var d = 0;
        for (var i = 0; i < 32; i++) {
            d |= x[i] ^ y[i];
        }
        return (1 & ((d - 1) >>> 8)) === 1;
    }
    /**
     * @param {number[]} o
     * @param {number[]} n
     * @private
     * @internal
     */
    function unpack25519(o, n) {
        for (var i = 0; i < 16; i++) {
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 0x7fff;
    }
    /**
     * @param {number[]} o
     * @param {number[]} i
     * @private
     * @internal
     */
    function pow2523(o, i) {
        var c = [];
        for (var a = 0; a < 16; a++) {
            c[a] = i[a];
        }
        for (var a = 250; a >= 0; a--) {
            fnM(c, c, c);
            if (a !== 1) {
                fnM(c, c, i);
            }
        }
        for (var a = 0; a < 16; a++) {
            o[a] = c[a];
        }
    }
    /**
     * @param {number[]} a
     * @param {number[]} b
     * @throws {boolean}
     * @private
     * @internal
     */
    function neq25519(a, b) {
        var c = [];
        var d = [];
        pack25519(c, a);
        pack25519(d, b);
        return cryptoVerify32(c, d);
    }
    /**
     * @param {number[]|Uint8Array|Buffer} seed
     * @returns {number[]}
     */
    function secretKeyFromSeed(seed) {
        var sk = [];
        var pk = [];
        var p = [[], [], [], []];
        arraySet(sk, seed);
        var d = sha512(sk);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        return sk.concat(pk);
    }
    /**
     * @param {number} value
     * @returns {number[]}
     */
    function uint64ToBytes(value) {
        var l = 1;
        var h = (value - l) / 4294967296; // value >>> 32
        return [(h >>> 24) & 0xff, (h >>> 16) & 0xff, (h >>> 8) & 0xff, h & 0xff,
            (l >>> 24) & 0xff, (l >>> 16) & 0xff, (l >>> 8) & 0xff, l & 0xff];
    }
    /**
     * @param {number[]} bytes
     * @returns {number}
     * @throws {Error}
     */
    function bytesToUint64(bytes) {
        if (((bytes[0] << 8) + bytes[1]) > 0x001f) {
            throw new Error('value is not safe integer');
        }
        var h = (bytes[69] << 24) + (bytes[70] << 16) + (bytes[71] << 8) + bytes[72];
        var l = (bytes[73] << 24) + (bytes[74] << 16) + (bytes[75] << 8) + bytes[76];
        return (h * 4294967296) + l; // h << 32 | l
    }
    var sha256K = [
        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
    ];
    /**
     * –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è, SHA2-256.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]|Uint8Array|Buffer} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha256(message) {
        // SHA-256 initial hash values.
        var h = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha256PreProcess(message);
        // Process the message in successive 512-bit chunks / 16 32-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 64; i++) {
                var s0 = rotr(w[i - 15], 7) ^ rotr(w[i - 15], 18) ^ (w[i - 15] >>> 3);
                var s1 = rotr(w[i - 2], 17) ^ rotr(w[i - 2], 19) ^ (w[i - 2] >>> 10);
                w[i] = w[i - 16] + s0 + w[i - 7] + s1;
            }
            // Compression function main loop.
            sha256Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v >>> 24 & 0xff), (v >>> 16 & 0xff), (v >>> 8 & 0xff), (v & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]|Uint8Array|Buffer} message
     * @returns {number[][]}
     */
    function sha256PreProcess(message) {
        var bytes = [];
        // Length a multiple of 512 bits
        for (var i = 0, l = message.length + 8 + (64 - ((message.length + 8) % 64)); i < l; i++) {
            bytes[i] = message[i] || 0;
        }
        bytes[message.length] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 64-bit big-endian integer
        bytes[bytes.length - 2] = ((message.length * 8) >>> 8) & 0xff;
        bytes[bytes.length - 1] = (message.length * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytes.length; i < l; i += 64) {
            var chunk = [];
            for (var j = 0; j < 64; j += 4) {
                var n = i + j;
                chunk.push((bytes[n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {number[]} h
     * @param {number[]} w
     */
    function sha256Block(h, w) {
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = v; // deep copy
        });
        for (var i = 0; i < 64; i++) {
            var S1 = rotr(a[4], 6) ^ rotr(a[4], 11) ^ rotr(a[4], 25);
            var ch = (a[4] & a[5]) ^ ((~a[4]) & a[6]);
            var t1 = a[7] + S1 + ch + sha256K[i] + w[i];
            var S0 = rotr(a[0], 2) ^ rotr(a[0], 13) ^ rotr(a[0], 22);
            var ma = (a[0] & a[1]) ^ (a[0] & a[2]) ^ (a[1] & a[2]);
            var t2 = S0 + ma;
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = a[3] + t1;
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = t1 + t2;
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = h[i] + v | 0; // clamp 32bit
        });
    }
    /**
     * @param {number} n
     * @param {number} i
     * @returns {number}
     */
    function rotr(n, i) {
        return (n >>> i) | (n << (32 - i));
    }
    var sha512K = [
        [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538],
        [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],
        [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235],
        [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],
        [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab],
        [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],
        [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed],
        [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],
        [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218],
        [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],
        [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373],
        [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],
        [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c],
        [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],
        [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc],
        [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]
    ];
    /**
     * –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è, SHA2-512.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]|Uint8Array|Buffer} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha512(message) {
        // SHA-512 initial hash values.
        var h = [
            [0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1],
            [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]
        ];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha512PreProcess(message);
        // Process the message in successive 1024-bit chunks / 16 64-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 80; i++) {
                var s0 = xor64(xor64(rotr64(w[i - 15], 1), rotr64(w[i - 15], 8)), shft64(w[i - 15], 7));
                var s1 = xor64(xor64(rotr64(w[i - 2], 19), rotr64(w[i - 2], 61)), shft64(w[i - 2], 6));
                w[i] = sum64(sum64(w[i - 16], s0), sum64(w[i - 7], s1));
            }
            // Compression function main loop.
            sha512Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v[0] >>> 24 & 0xff), (v[0] >>> 16 & 0xff), (v[0] >>> 8 & 0xff), (v[0] & 0xff));
            digest.push((v[1] >>> 24 & 0xff), (v[1] >>> 16 & 0xff), (v[1] >>> 8 & 0xff), (v[1] & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]|Uint8Array|Buffer} message
     * @returns {[number, number][][]}
     */
    function sha512PreProcess(message) {
        var bytez = [];
        // Length a multiple of 1024 bits
        for (var i = 0, l = message.length + 16 + (128 - ((message.length + 16) % 128)); i < l; i++) {
            bytez[i] = message[i] || 0;
        }
        bytez[message.length] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 128-bit big-endian integer
        bytez[bytez.length - 2] = ((message.length * 8) >>> 8) & 0xff;
        bytez[bytez.length - 1] = (message.length * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytez.length; i < l; i += 128) {
            var chunk = [];
            for (var j = 0; j < 128; j += 8) {
                var n = i + j;
                chunk.push([
                    (bytez[n] << 24) + (bytez[++n] << 16) + (bytez[++n] << 8) + bytez[++n],
                    (bytez[++n] << 24) + (bytez[++n] << 16) + (bytez[++n] << 8) + bytez[++n]
                ]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {[number, number][]} h
     * @param {[number, number][]} w
     */
    function sha512Block(h, w) {
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = [v[0], v[1]]; // deep copy
        });
        // Compression function main loop.
        for (var i = 0; i < 80; i++) {
            var S1 = xor64(xor64(rotr64(a[4], 14), rotr64(a[4], 18)), rotr64(a[4], 41));
            var ch = xor64(and64(a[4], a[5]), and64(not64(a[4]), a[6]));
            var t1 = sum64(sum64(sum64(a[7], S1), sum64(ch, sha512K[i])), w[i]);
            var S0 = xor64(xor64(rotr64(a[0], 28), rotr64(a[0], 34)), rotr64(a[0], 39));
            var ma = xor64(xor64(and64(a[0], a[1]), and64(a[0], a[2])), and64(a[1], a[2]));
            var t2 = sum64(S0, ma);
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = sum64(a[3], t1);
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = sum64(t1, t2);
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = sum64(h[i], v);
        });
    }
    function shft64(n, i) {
        return [(n[0] >>> i), (n[1] >>> i) | (n[0] << (32 - i))];
    }
    function rotr64(n, i) {
        if (i < 32) {
            return [n[0] >>> i | n[1] << (32 - i), n[1] >>> i | n[0] << (32 - i)];
        }
        return [
            n[1] >>> (i - 32) | n[0] << (32 - (i - 32)),
            n[0] >>> (i - 32) | n[1] << (32 - (i - 32))
        ];
    }
    function xor64(a, b) {
        return [(a[0] ^ b[0]), (a[1] ^ b[1])];
    }
    function and64(a, b) {
        return [(a[0] & b[0]), (a[1] & b[1])];
    }
    function not64(n) {
        return [~n[0], ~n[1]];
    }
    /**
     * @param {[number, number]} a
     * @param {[number, number]} b
     * @returns {[number, number]}
     * @private
     * @internal
     */
    function sum64(a, b) {
        var x = [0, 0, 0, 0];
        x[3] = (a[1] & 0xffff) + (b[1] & 0xffff);
        x[2] = (a[1] >>> 16) + (b[1] >>> 16) + (x[3] >>> 16);
        x[1] = (a[0] & 0xffff) + (b[0] & 0xffff) + (x[2] >>> 16);
        x[0] = (a[0] >>> 16) + (b[0] >>> 16) + (x[1] >>> 16);
        return [((x[0] & 0xffff) << 16) + (x[1] & 0xffff), ((x[2] & 0xffff) << 16) + (x[3] & 0xffff)];
    }
    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ UTF-8 –±–∞–π—Ç–æ–≤.
     * @function
     * @param {string} text
     * @returns {number[]}
     * @private
     */
    function Utf8Encode(text) {
        var bytes = [];
        for (var i = 0; i < text.length; i++) {
            var code = text.charCodeAt(i);
            if (code < 0x80) { // ascii
                bytes.push(code);
            }
            else if (code < 0x800) {
                bytes.push(0xc0 | (code >> 6), 0x80 | (code & 0x3f));
            }
            else if (code < 0xd800 || code >= 0xe000) {
                bytes.push((0xe0 | (code >> 12)), (0x80 | ((code >> 6) & 0x3f)));
                bytes.push(0x80 | (code & 0x3f));
            }
            else { // surrogate pair
                code = 0x10000 + ((code & 0x3ff) << 10) + (text.charCodeAt(++i) & 0x3ff);
                bytes.push((0xf0 | (code >> 18)), (0x80 | ((code >> 12) & 0x3f)));
                bytes.push((0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)));
            }
        }
        return bytes;
    }
    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –∏–∑ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ UTF-8 –±–∞–π—Ç–æ–≤ –≤ —Å—Ç—Ä–æ–∫—É.
     * @function
     * @param {number[]|Uint8Array|Buffer} bytes
     * @returns {string}
     * @private
     */
    function Utf8Decode(bytes) {
        var str = '';
        for (var i = 0; i < bytes.length; i++) {
            if (bytes[i] < 0x80) { // ascii
                str += String.fromCharCode(bytes[i]);
            }
            else if (bytes[i] > 0xBF && bytes[i] < 0xE0) {
                str += String.fromCharCode((bytes[i] & 0x1F) << 6 | bytes[++i] & 0x3F);
            }
            else if (bytes[i] > 0xDF && bytes[i] < 0xF0) {
                str += String.fromCharCode((bytes[i] & 0x0F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F);
            }
            else { // surrogate pair
                var code = ((bytes[i] & 0x07) << 18 | (bytes[++i] & 0x3F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F) - 0x010000;
                str += String.fromCharCode(code >> 10 | 0xD800, code & 0x03FF | 0xDC00);
            }
        }
        return str;
    }
    /**
     * @param {number} arg
     * @param {number} min
     * @param {number} max
     * @throws {Error}
     */
    function validateInt(arg, min, max) {
        if (typeof arg !== 'number') {
            throw new Error('incorrect type');
        }
        if (Math.floor(arg) !== arg) {
            throw new Error('not integer');
        }
        if (arg < min || arg > max) {
            throw new Error('incorrect value');
        }
    }
    /**
     * @param {string} arg
     * @param {number} [len]
     */
    function validateStr(arg, len) {
        if (typeof arg !== 'string') {
            throw new Error('incorrect type');
        }
        if (len !== undefined && arg.length !== len) {
            throw new Error('incorrect length');
        }
    }

    exports.Address = Address;
    exports.Block = Block;
    exports.BlockHeader = BlockHeader;
    exports.PublicKey = PublicKey;
    exports.SecretKey = SecretKey;
    exports.Transaction = Transaction;

    return exports;

}({}));
