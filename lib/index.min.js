/**
 * @license
 * Copyright (c) 2020 UMI
 * MIT Licensed
 */

var umi = (function (exports) {
    'use strict';

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Базовый класс для работы с адресами.
     * @class
     */
    var Address = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array} [bytes] Адрес в бинарном виде, длина 34 байта.
         * @throws {Error}
         */
        function Address(bytes) {
            /**
             * Адрес в бинарном виде, длина 34 байта.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes === undefined) {
                this.version = Address.Umi;
            }
            else {
                if (bytes.length !== 34) {
                    throw new Error('bytes length must be 34 bytes');
                }
                for (var i = 0; i < 34; i++) {
                    this._bytes[i] = bytes[i];
                }
            }
        }
        Object.defineProperty(Address, "Genesis", {
            /**
             * Версия Genesis-адрса.
             * @type {number}
             * @constant
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address, "Umi", {
            /**
             * Версия Umi-адреса.
             * @type {number}
             * @constant
             */
            get: function () { return 21929; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "bytes", {
            /**
             * Адрес в бинарном виде, длина 34 байта.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Address.prototype, "version", {
            /**
             * Версия адреса, префикс в числовом виде.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                // version length = 2
                // version offset = 0
                return (this._bytes[0] << 8) + this._bytes[1];
            },
            set: function (version) {
                versionToPrefix(version); // validation
                // tslint:disable-next-line:no-bitwise
                this._bytes[0] = (version >> 8) & 0xff;
                this._bytes[1] = version & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает версию адреса и возвращяет this.
         * @param {number} version Версия адреса.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(Address.prototype, "publicKey", {
            /**
             * Публичный ключ.
             * @type {PublicKey}
             * @throws {Error}
             */
            get: function () {
                // public key begin = 2
                return new PublicKey(this._bytes.slice(2));
            },
            set: function (publicKey) {
                if (!(publicKey instanceof PublicKey)) {
                    throw new Error('publicKey type must be PublicKey');
                }
                // public key offset = 2
                var b = publicKey.bytes;
                for (var i = 0; i < 32; i++) {
                    this._bytes[2 + i] = b[i];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает публичный ключи и возвращяет this.
         * @param {PublicKey} publicKey Публичный ключ.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPublicKey = function (publicKey) {
            this.publicKey = publicKey;
            return this;
        };
        Object.defineProperty(Address.prototype, "prefix", {
            /**
             * Префикс адреса, три символа латиницы в нижнем регистре.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return versionToPrefix(this.version);
            },
            set: function (prefix) {
                this.version = prefixToVersion(prefix);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает префикс адреса и возвращяет this.
         * @param {string} prefix Префикс адреса, три символа латиницы в нижнем регистре.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Address.prototype, "bech32", {
            /**
             * Адрес в формате Bech32, длина 62 символа.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                return encode(this._bytes);
            },
            set: function (bech32) {
                var b = decode(bech32);
                for (var i = 0; i < 32; i++) {
                    this._bytes[i] = b[i];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает адрес в формате Bech32.
         * @param {string} bech32 Адрес в формате Bech32, длина 62 символа.
         * @returns {Address}
         * @throws {Error}
         */
        Address.prototype.setBech32 = function (bech32) {
            this.bech32 = bech32;
            return this;
        };
        /**
         * Статический фабричный метод, создающий объект из адреса в формате Bech32.
         * @param {string} bech32 Адрес в формате Bech32, длина 62 символа.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromBech32 = function (bech32) {
            return new Address().setBech32(bech32);
        };
        /**
         * Статический фабричный метод, создающий объект из публичного или приватного ключа.
         * @param {PublicKey|SecretKey} key Публичный или приватный ключ.
         * @returns {Address}
         * @throws {Error}
         */
        Address.fromKey = function (key) {
            if (key instanceof SecretKey) {
                return new Address().setPublicKey(key.publicKey);
            }
            if (key instanceof PublicKey) {
                return new Address().setPublicKey(key);
            }
            throw new Error('key type must be PublicKey or SecretKey');
        };
        return Address;
    }());
    /**
     * Базовый класс для работы с блоками.
     * @class
     */
    var Block = /** @class */ (function () {
        function Block() {
        }
        return Block;
    }());
    /**
     * Базовый класс для работы с заголовками блоков.
     * @class
     */
    var BlockHeader = /** @class */ (function () {
        function BlockHeader() {
        }
        return BlockHeader;
    }());
    /**
     * Базовый класс для работы с публичными ключами.
     * @class
     */
    var PublicKey = /** @class */ (function () {
        /**
         * @param {number[]} bytes Публичный ключ в формате libsodium, 32 байта (256 бит).
         * @throws {Error}
         */
        function PublicKey(bytes) {
            /**
             * Публичный ключ в бинарном виде. В формате libsodium.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes.length !== 32) {
                throw new Error('invalid length');
            }
            for (var i = 0; i < 32; i++) {
                this._bytes[i] = bytes[i];
            }
        }
        Object.defineProperty(PublicKey, "LENGTH", {
            /**
             * Длина публичного ключа в формате libsodium в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 32; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey, "SIGNATURE_LENGTH", {
            /**
             * Длина цифровой подписи в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "signatureLength", {
            /**
             * Длина цифровой подписи в байтах.
             * @type {number}
             * @constant
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PublicKey.prototype, "bytes", {
            /**
             * Публичный ключ в формате libsodium, 32 байта (256 бит).
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0, 32);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Проверяет цифровую подпись.
         * @param {number[]|Uint8Array|Buffer} signature Подпись, 64 байта.
         * @param {number[]|Uint8Array|Buffer} message Сообщение
         * @returns {boolean}
         * @throws {Error}
         * @example
         * let key = new Uint8Array(32)
         * let sig = new Uint8Array(64)
         * let msg = new Uint8Array(1)
         * let ver = new PublicKey(key).verifySignature(sig, msg)
         */
        PublicKey.prototype.verifySignature = function (signature, message) {
            if (signature.length !== 64) {
                throw new Error('invalid length');
            }
            return verify(signature, message, this._bytes);
        };
        return PublicKey;
    }());
    /**
     * Базовый класс для работы с приватными ключами.
     * @class
     */
    var SecretKey = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array|Buffer} bytes Приватный ключ в бинарном виде.
         * В формате libsodium, 64 байта (512 бит).
         * @throws {Error}
         */
        function SecretKey(bytes) {
            /**
             * Приватный ключ в бинарном виде. В формате libsodium.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            if (bytes.length !== 64) {
                throw new Error('invalid length');
            }
            for (var i = 0; i < 64; i++) {
                this._bytes[i] = bytes[i];
            }
        }
        Object.defineProperty(SecretKey, "LENGTH", {
            /**
             * Длина приватного ключа в формате libsodium в байтах.
             * @type {number}
             * @internal
             */
            get: function () { return 64; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "bytes", {
            /**
             * Приватный ключ в бинарном виде. В формате libsodium, 64 байта (512 бит).
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0, 64);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SecretKey.prototype, "publicKey", {
            /**
             * Публичный ключ, соответствующий приватному ключу.
             * @type {PublicKey}
             * @readonly
             */
            get: function () {
                return new PublicKey(this._bytes.slice(32, 64));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Создает цифровую подпись сообщения.
         * @param {number[]|Uint8Array|Buffer} message Сообщение, которое необходимо подписать.
         * @returns {number[]} Цифровая подпись длиной 64 байта (512 бит).
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let msg = new Uint8Array(1)
         * let sig = SecretKey.fromSeed(seed).sign(msg)
         */
        SecretKey.prototype.sign = function (message) {
            return sign(message, this._bytes);
        };
        /**
         * Статический фабричный метод, создающий приватный ключ из seed.
         * Libsodium принимает seed длиной 32 байта (256 бит), если длина
         * отличается, то берется sha256 хэш.
         * @param {number[]|Uint8Array|Buffer} seed Seed длиной от 0 до 128 байт.
         * @returns {SecretKey}
         * @throws {Error}
         * @example
         * let seed = new Uint8Array(32)
         * let key = SecretKey.fromSeed(seed)
         */
        SecretKey.fromSeed = function (seed) {
            var entropy = seed;
            if (seed.length !== 32) {
                entropy = sha256(entropy);
            }
            return new SecretKey(secretKeyFromSeed(entropy));
        };
        return SecretKey;
    }());
    /**
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransaction = /** @class */ (function () {
        /**
         * @param {number[]|Uint8Array|Buffer} [bytes] Транзакция в бинарном виде, 150 байт.
         * @throws {Error}
         * @private
         */
        function AbstractTransaction(bytes) {
            /**
             * Транзакция в бинарном виде.
             * @type {number[]}
             * @private
             * @internal
             */
            this._bytes = [];
            /**
             * Заполоненные свойства.
             * @type {Object}
             * @private
             * @internal
             */
            this._fieldsMap = {};
            arrayFill(this._bytes, 150);
            if (bytes !== undefined) {
                if (bytes.length !== 150) {
                    throw new Error('incorrect length');
                }
                arraySet(this._bytes, bytes);
                this._setFields([
                    'version', 'sender', 'recipient', 'value', 'prefix',
                    'name', 'profitPercent', 'feePercent', 'nonce', 'signature'
                ]);
            }
        }
        Object.defineProperty(AbstractTransaction, "Genesis", {
            /**
             * Genesis-транзакция.
             * Может быть добавлена только в Genesis-блок.
             * Адрес отправителя должен иметь префикс genesis, адрес получаетеля - umi.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('genesis')
             * let recipient = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.Genesis).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 0; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "Basic", {
            /**
             * Стандартная транзакция. Перевод монет из одного кошелька в другой.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let recipient = Address.fromKey(secKey).setPrefix('aaa')
             * let tx = new Transaction().
             *   setVersion(Transaction.Basic).
             *   setSender(sender).
             *   setRecipient(recipient).
             *   setValue(42).
             *   sign(secKey)
             */
            get: function () { return 1; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateStructure", {
            /**
             * Создание новой структуры.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('🙂').
             *   setProfitPercent(100).
             *   setFeePercent(0).
             *   sign(secKey)
             */
            get: function () { return 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateStructure", {
            /**
             * Обновление настроек существующей структуры.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateStructure).
             *   setSender(sender).
             *   setPrefix('aaa').
             *   setName('🙂').
             *   setProfitPercent(500).
             *   setFeePercent(2000).
             *   sign(secKey)
             */
            get: function () { return 3; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateProfitAddress", {
            /**
             * Изменение адреса для начисления профита.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newPrf = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateProfitAddress).
             *   setSender(sender).
             *   setRecipient(newPrf).
             *   sign(secKey)
             */
            get: function () { return 4; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "UpdateFeeAddress", {
            /**
             * Изменение адреса на который переводоится комиссия.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let newFee = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.UpdateFeeAddress).
             *   setSender(sender).
             *   setRecipient(newFee).
             *   sign(secKey)
             */
            get: function () { return 5; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "CreateTransitAddress", {
            /**
             * Активация транзитного адреса.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.CreateTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 6; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransaction, "DeleteTransitAddress", {
            /**
             * Деактивация транзитного адреса.
             * @type {number}
             * @constant
             * @example
             * let secKey = SecretKey.fromSeed(new Uint8Array(32))
             * let sender = Address.fromKey(secKey).setPrefix('umi')
             * let transit = Address.fromBech32('aaa18d4z00xwk6jz6c4r4rgz5mcdwdjny9thrh3y8f36cpy2rz6emg5svsuw66')
             * let tx = new Transaction().
             *   setVersion(Transaction.DeleteTransitAddress).
             *   setSender(sender).
             *   setRecipient(transit).
             *   sign(secKey)
             */
            get: function () { return 7; },
            enumerable: false,
            configurable: true
        });
        /**
         * Проверить наличие свойства.
         * @param {string[]} fields
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransaction.prototype._checkFields = function (fields) {
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var field = fields_1[_i];
                if (!Object.prototype.hasOwnProperty.call(this._fieldsMap, field)) {
                    throw new Error(field + " must be set");
                }
            }
        };
        /**
         * Отметить свойство как установленное.
         * @param {string[]} fields
         * @private
         * @internal
         */
        AbstractTransaction.prototype._setFields = function (fields) {
            for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
                var field = fields_2[_i];
                this._fieldsMap[field] = true;
            }
        };
        return AbstractTransaction;
    }());
    /**
     * Базовый класс для работы с транзакциями.
     * @class
     * @lends Transaction
     * @private
     */
    var AbstractTransactionBase = /** @class */ (function (_super) {
        __extends(AbstractTransactionBase, _super);
        function AbstractTransactionBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AbstractTransactionBase.prototype, "bytes", {
            /**
             * Транзакция в бинарном виде, 150 байт.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return this._bytes.slice(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "hash", {
            /**
             * Хэш транзакции, sha256 от всех 150 байт.
             * @type {number[]}
             * @readonly
             */
            get: function () {
                return sha256(this._bytes);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractTransactionBase.prototype, "version", {
            /**
             * Версия (тип) транзакции.
             * Обязательное поле, необходимо задать сразу после создания новой транзакции.
             * Изменять тип транзакции, после того как он был задан, нельзя.
             * @type {number}
             * @throws {Error}
             * @see Transaction.Genesis
             * @see Transaction.Basic
             * @see Transaction.CreateStructure
             * @see Transaction.UpdateStructure
             * @see Transaction.UpdateProfitAddress
             * @see Transaction.UpdateFeeAddress
             * @see Transaction.CreateTransitAddress
             * @see Transaction.DeleteTransitAddress
             */
            get: function () {
                this._checkFields(['version']);
                return this._bytes[0];
            },
            set: function (version) {
                if (Object.prototype.hasOwnProperty.call(this._fieldsMap, 'version')) {
                    throw new Error('could not update version');
                }
                validateInt(version, 0, 7);
                this._bytes[0] = version;
                this._setFields(['version']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает версию и возвращяет this.
         * @param {number} version Версия адреса.
         * @returns {this}
         * @throws {Error}
         * @see Transaction.Genesis
         * @see Transaction.Basic
         * @see Transaction.CreateStructure
         * @see Transaction.UpdateStructure
         * @see Transaction.UpdateProfitAddress
         * @see Transaction.UpdateFeeAddress
         * @see Transaction.CreateTransitAddress
         * @see Transaction.DeleteTransitAddress
         */
        AbstractTransactionBase.prototype.setVersion = function (version) {
            this.version = version;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "sender", {
            /**
             * Отправитель. Доступно для всех типов транзакций.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['sender']);
                // sender length = 34
                // sender begin = 1
                // sender end = 35
                return new Address(this._bytes.slice(1, 35));
            },
            set: function (address) {
                this._checkFields(['version']);
                if (!(address instanceof Address)) {
                    throw new Error('address type must be Address');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Genesis) {
                    throw new Error('address version must be genesis');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    address.version === Address.Genesis) {
                    throw new Error('address version must not be genesis');
                }
                // sender offset = 1
                arraySet(this._bytes, address.bytes, 1);
                this._setFields(['sender']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает отправителя и возвращяет this.
         * @param {Address} address Адрес получателя.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSender = function (address) {
            this.sender = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "recipient", {
            /**
             * Получатель.
             * Недоступно для транзакций CreateStructure и UpdateStructure.
             * @type {Address}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                this._checkFields(['recipient']);
                // recipient begin = 35
                // recipient end = 69
                return new Address(this._bytes.slice(35, 69));
            },
            set: function (address) {
                this._checkFields(['version']);
                this._checkVersionIsNotStruct();
                if (!(address instanceof Address)) {
                    throw new Error('recipient type must be Address');
                }
                if (address.version === Address.Genesis) {
                    throw new Error('recipient version must not be genesis');
                }
                if (this.version === AbstractTransactionBase.Genesis &&
                    address.version !== Address.Umi) {
                    throw new Error('recipient version must be umi');
                }
                if (this.version !== AbstractTransactionBase.Genesis &&
                    this.version !== AbstractTransactionBase.Basic &&
                    address.version === Address.Umi) {
                    throw new Error('recipient version must not be umi');
                }
                // recipient offset = 35
                arraySet(this._bytes, address.bytes, 35);
                this._setFields(['recipient']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает получателя и возвращяет this.
         * Доступно для всех типов транзакций кроме CreateStructure и UpdateStructure.
         * @param {Address} address Адрес получателя.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setRecipient = function (address) {
            this.recipient = address;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "value", {
            /**
             * Сумма перевода в UMI-центах, цело число в промежутке от 1 до 18446744073709551615.
             * Из-за ограничений JavaScript максимальное доступное значение 9007199254740991.
             * Доступно только для Genesis и Basic транзакций.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                this._checkFields(['value']);
                // value offset = 69
                return bytesToUint64(this._bytes.slice(69, 76));
            },
            set: function (value) {
                this._checkFields(['version']);
                this._checkVersionIsBasic();
                validateInt(value, 1, 9007199254740991);
                // value offset = 69
                arraySet(this._bytes, uint64ToBytes(value), 69);
                this._setFields(['value']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает сумму и возвращяет this.
         * Принимает значения в промежутке от 1 до 9007199254740991.
         * Доступно только для Genesis и Basic транзакций.
         * @param {number} value
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setValue = function (value) {
            this.value = value;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "nonce", {
            /**
             * Nonce, целое число в промежутке от 0 до 18446744073709551615.
             * Из-за ограничений JavaScript максимальное доступное значение 9007199254740991.
             * Генерируется автоматичеки при вызове sign().
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['nonce']);
                // nonce offset = 77
                return bytesToUint64(this._bytes.slice(77, 85));
            },
            set: function (nonce) {
                validateInt(nonce, 0, 9007199254740991);
                // nonce offset = 77
                arraySet(this._bytes, uint64ToBytes(nonce), 77);
                this._setFields(['nonce']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает nonce и возвращяет this.
         * @param {number} nonce Nonce, целое числов промежутке от 0 до 9007199254740991.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setNonce = function (nonce) {
            this.nonce = nonce;
            return this;
        };
        Object.defineProperty(AbstractTransactionBase.prototype, "signature", {
            /**
             * Цифровая подпись транзакции, длина 64 байта.
             * Генерируется автоматически при вызове sign().
             * @type {number[]}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['signature']);
                // signature length = 64
                var len = this.sender.publicKey.signatureLength;
                // signature offset = 85
                return this._bytes.slice(85, 85 + len);
            },
            set: function (signature) {
                this._checkFields(['version', 'sender']);
                if (signature.length !== this.sender.publicKey.signatureLength) {
                    throw new Error('invalid length');
                }
                // signature offset = 85
                arraySet(this._bytes, signature, 85);
                this._setFields(['signature']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает цифровую подпись и возвращяет this.
         * @param {number[]|Uint8Array|Buffer} signature Подпись, длина 64 байта.
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.setSignature = function (signature) {
            this.signature = signature;
            return this;
        };
        /**
         * Подписать транзакцию приватным ключем.
         * @param {SecretKey} secretKey
         * @returns {this}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.sign = function (secretKey) {
            this._checkFields(['version', 'sender']);
            if (!(secretKey instanceof SecretKey)) {
                throw new Error('secretKey type must be SecretKey');
            }
            // unsigned begin = 0
            // unsigned end = 85
            this.signature = secretKey.sign(this._bytes.slice(0, 85));
            return this;
        };
        /**
         * Проверить транзакцию на соотвествие формальным правилам.
         * @returns {boolean}
         * @throws {Error}
         */
        AbstractTransactionBase.prototype.verify = function () {
            this._checkFields(['version', 'sender', 'signature']);
            // unsigned begin = 0
            // unsigned end = 85
            return this.sender.publicKey.verifySignature(this.signature, this._bytes.slice(0, 85));
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsBasic = function () {
            var versions = [AbstractTransaction.Genesis, AbstractTransaction.Basic];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        AbstractTransactionBase.prototype._checkVersionIsNotStruct = function () {
            var versions = [AbstractTransaction.CreateStructure, AbstractTransaction.UpdateStructure];
            if (versions.indexOf(this.version) !== -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        return AbstractTransactionBase;
    }(AbstractTransaction));
    /**
     * Класс для работы с транзакциями.
     * @class
     * @param {number[]} [bytes] Транзакция в бинарном виде, 150 байт.
     * @throws {Error}
     */
    var Transaction = /** @class */ (function (_super) {
        __extends(Transaction, _super);
        function Transaction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @throws {Error}
         * @private
         * @internal
         */
        Transaction.prototype._checkVersionIsStruct = function () {
            var versions = [Transaction.CreateStructure, Transaction.UpdateStructure];
            if (versions.indexOf(this.version) === -1) {
                throw new Error('unavailable for this transaction type');
            }
        };
        Object.defineProperty(Transaction.prototype, "prefix", {
            /**
             * Префикс адресов, принадлежащих структуре.
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['prefix']);
                // prefix offset = 35
                var ver = (this._bytes[35] << 8) + this._bytes[36];
                return versionToPrefix(ver);
            },
            set: function (prefix) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                var ver = prefixToVersion(prefix);
                // prefix offset = 35
                this._bytes[35] = (ver >>> 8) & 0xff;
                this._bytes[36] = ver & 0xff;
                this._setFields(['prefix']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает префикс и возвращяет this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {string} prefix Префикс адресов, принадлежащих структуре.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setPrefix = function (prefix) {
            this.prefix = prefix;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "name", {
            /**
             * Название структуры в кодировке UTF-8.
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {string}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['name']);
                // name offset = 41
                var txt = this._bytes.slice(42, 42 + this._bytes[41]);
                return Utf8Decode(txt);
            },
            set: function (name) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                if (typeof name !== 'string') {
                    throw new Error('name type must be a string');
                }
                var txt = Utf8Encode(name);
                if (txt.length >= 36) {
                    throw new Error('name is too long');
                }
                // name length = 36
                // name offset = 41
                this._bytes[41] = txt.length;
                for (var i = 0; i < 35; i++) {
                    this._bytes[42 + i] = txt[i] || 0;
                }
                this._setFields(['name']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает название структуры.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {string} name Название структуры в кодировке UTF-8.
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setName = function (name) {
            this.name = name;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "profitPercent", {
            /**
             * Профита в сотых долях процента с шагом в 0.01%.
             * Валидные значения от 100 до 500 (соотвественно от 1% до 5%).
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['profitPercent']);
                // profit offset = 37
                return (this._bytes[37] << 8) + this._bytes[38];
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 100, 500);
                // profit offset = 37
                this._bytes[37] = (percent >>> 8) & 0xff;
                this._bytes[38] = percent & 0xff;
                this._setFields(['profitPercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает процент профита и возвращяет this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {number} percent Профит в сотых долях процента с шагом в 0.01%. Валидные значения от 100 до 500 (соотвественно от 1% до 5%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setProfitPercent = function (percent) {
            this.profitPercent = percent;
            return this;
        };
        Object.defineProperty(Transaction.prototype, "feePercent", {
            /**
             * Комиссия в сотых долях процента с шагом в 0.01%.
             * Валидные значения от 0 до 2000 (соотвественно от 0% до 20%).
             * Доступно только для CreateStructure и UpdateStructure.
             * @type {number}
             * @throws {Error}
             */
            get: function () {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                this._checkFields(['feePercent']);
                // fee offset = 39
                return (this._bytes[39] << 8) + this._bytes[40];
            },
            set: function (percent) {
                this._checkFields(['version']);
                this._checkVersionIsStruct();
                validateInt(percent, 0, 2000);
                // fee offset = 39
                this._bytes[39] = (percent >>> 8) & 0xff;
                this._bytes[40] = percent & 0xff;
                this._setFields(['feePercent']);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Устанавливает размер комиссии и возвращает this.
         * Доступно только для CreateStructure и UpdateStructure.
         * @param {number} percent Комиссия в сотых долях процента с шагом в 0.01%. Валидные значения от 0 до 2000 (соотвественно от 0% до 20%).
         * @returns {this}
         * @throws {Error}
         */
        Transaction.prototype.setFeePercent = function (percent) {
            this.feePercent = percent;
            return this;
        };
        return Transaction;
    }(AbstractTransactionBase));
    /**
     * @param {number[]} array
     * @param {number} [length]
     * @param [value]
     */
    function arrayFill(array, length, value) {
        var v = value || 0;
        for (var i = 0; i < length; i++) {
            array[i] = v;
        }
    }
    /**
     * @param {number[]} a
     * @param {number[]} b
     * @param {number} offset
     * @param {number} length
     */
    function arraySet(a, b, offset, length) {
        var o = offset || 0;
        var l = length || b.length;
        for (var i = 0; i < l; i++) {
            a[o + i] = b[i];
        }
    }
    var alphabet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
    /**
     * @param {number[]|Uint8Array|Buffer} bytes
     * @returns {string}
     */
    function encode(bytes) {
        var version = (bytes[0] << 8) + bytes[1];
        var prefix = versionToPrefix(version);
        var data = convert8to5(bytes.slice(2));
        var checksum = createChecksum(prefix, data);
        return prefix + '1' + data + checksum;
    }
    /**
     * @param {string} bech32
     * @returns {number[]}
     */
    function decode(bech32) {
        if (bech32.length !== 62 && bech32.length !== 66) {
            throw new Error('bech32: invalid length');
        }
        var str = bech32.toLowerCase();
        var sepPos = str.lastIndexOf('1');
        if (sepPos === -1) {
            throw new Error('bech32: missing separator');
        }
        var pfx = str.slice(0, sepPos);
        var ver = prefixToVersion(pfx);
        var data = str.slice(sepPos + 1);
        checkAlphabet(data);
        verifyChecksum(pfx, data);
        var res = [];
        res[0] = (ver >>> 8) & 0xff;
        res[1] = ver & 0xff;
        return res.concat(convert5to8(data.slice(0, -6)));
    }
    function convert5to8(data) {
        var value = 0;
        var bits = 0;
        var bytes = strToBytes(data);
        var result = [];
        for (var i = 0; i < bytes.length; i++) {
            value = (value << 5) | bytes[i];
            bits += 5;
            while (bits >= 8) {
                bits -= 8;
                result.push((value >> bits) & 0xff);
            }
        }
        if ((bits >= 5) || (value << (8 - bits)) & 0xff) {
            throw new Error('bech32: invalid data');
        }
        return result;
    }
    function convert8to5(data) {
        var value = 0;
        var bits = 0;
        var result = '';
        for (var i = 0; i < data.length; i++) {
            value = (value << 8) | data[i];
            bits += 8;
            while (bits >= 5) {
                bits -= 5;
                result += alphabet[(value >> bits) & 0x1f];
            }
        }
        /** @istanbul ignore else */
        if (bits > 0) {
            result += alphabet[(value << (5 - bits)) & 0x1f];
        }
        return result;
    }
    function createChecksum(prefix, data) {
        var bytes = strToBytes(data);
        var pfx = prefixExpand(prefix);
        var values = new Uint8Array(pfx.length + bytes.length + 6);
        values.set(pfx);
        values.set(bytes, pfx.length);
        var poly = polyMod(values) ^ 1;
        var checksum = '';
        for (var i = 0; i < 6; i++) {
            checksum += alphabet[(poly >> 5 * (5 - i)) & 31];
        }
        return checksum;
    }
    function polyMod(values) {
        var gen = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
        var chk = 1;
        for (var i = 0; i < values.length; i++) {
            var top_1 = chk >> 25;
            chk = (chk & 0x1ffffff) << 5 ^ values[i];
            for (var j = 0; j < 5; j++) {
                chk ^= ((top_1 >> j) & 1)
                    ? gen[j]
                    : 0;
            }
        }
        return chk;
    }
    function prefixExpand(prefix) {
        var res = [];
        res[prefix.length] = 0;
        for (var i = 0; i < prefix.length; i++) {
            var ord = prefix.charCodeAt(i);
            res[i] = ord >> 5;
            res[i + prefix.length + 1] = ord & 31;
        }
        return res;
    }
    function strToBytes(str) {
        var bytes = [];
        for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
            var chr = str_1[_i];
            bytes.push(alphabet.indexOf(chr));
        }
        return bytes;
    }
    function verifyChecksum(prefix, data) {
        var pfx = prefixExpand(prefix);
        var bytes = strToBytes(data);
        var values = new Uint8Array(pfx.length + bytes.length);
        values.set(pfx);
        values.set(bytes, pfx.length);
        var poly = polyMod(values);
        if (poly !== 1) {
            throw new Error('bech32: invalid checksum');
        }
    }
    function checkAlphabet(chars) {
        for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {
            var chr = chars_1[_i];
            if (alphabet.indexOf(chr) === -1) {
                throw new Error('bech32: invalid character');
            }
        }
    }
    /**
     * Конвертер цифровой версии префикса в текстовое представление.
     * @param {number} version
     * @returns {string}
     * @throws {Error}
     * @private
     */
    function versionToPrefix(version) {
        validateInt(version, 0, 65535);
        if (version === 0) {
            return 'genesis';
        }
        if ((version & 0x8000) === 0x8000) {
            throw new Error('bech32: incorrect version');
        }
        var a = (version & 0x7C00) >> 10;
        var b = (version & 0x03E0) >> 5;
        var c = (version & 0x001F);
        checkChars([a, b, c]);
        return String.fromCharCode((a + 96), (b + 96), (c + 96));
    }
    /**
     * Конвертер текстовой версии префикса в числовое представление.
     * @param {string} prefix
     * @returns {number}
     * @throws {Error}
     * @private
     */
    function prefixToVersion(prefix) {
        if (prefix === 'genesis') {
            return 0;
        }
        validateStr(prefix, 3);
        var a = prefix.charCodeAt(0) - 96;
        var b = prefix.charCodeAt(1) - 96;
        var c = prefix.charCodeAt(2) - 96;
        checkChars([a, b, c]);
        return (a << 10) + (b << 5) + c;
    }
    /**
     * @param {number[]} chars
     * @throws {Error}
     */
    function checkChars(chars) {
        for (var _i = 0, chars_2 = chars; _i < chars_2.length; _i++) {
            var chr = chars_2[_i];
            if (chr < 1 || chr > 26) {
                throw new Error('bech32: incorrect prefix character');
            }
        }
    }
    var gf0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var gf1 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var D2 = [
        0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
        0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
    ];
    var X = [
        0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
        0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
    ];
    var Y = [
        0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
        0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
    ];
    var L = [
        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
        0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
    ];
    /**
     * @param {number[]} r
     * @private
     * @internal
     */
    function reduce(r) {
        var x = r.slice(0);
        arrayFill(r, 64);
        modL(r, x);
    }
    /**
     * @param {number[]} r
     * @param {number[]} x
     * @private
     * @internal
     */
    function modL(r, x) {
        var carry;
        var j;
        var k;
        for (var i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256); // carry = (x[j] + 128) >> 8;
                x[j] -= carry * 256; // x[j] -= carry << 8;
            }
            x[j] += carry;
            x[i] = 0;
        }
        return modLSub(r, x);
    }
    function modLSub(r, x) {
        var carry = 0;
        for (var j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for (var j = 0; j < 32; j++) {
            x[j] -= carry * L[j];
        }
        for (var i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
        return r;
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @param {number[]} s
     * @private
     * @internal
     */
    function scalarmult(p, q, s) {
        arraySet(p[0], gf0);
        arraySet(p[1], gf1);
        arraySet(p[2], gf1);
        arraySet(p[3], gf0);
        for (var i = 255; i >= 0; --i) {
            var b = (s[(i / 8) | 0] >> (i & 7)) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @param {number} b
     * @private
     * @internal
     */
    function cswap(p, q, b) {
        for (var i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[][]} q
     * @private
     * @internal
     */
    function add(p, q) {
        var a = [];
        var b = [];
        var c = [];
        var d = [];
        var e = [];
        var f = [];
        var g = [];
        var h = [];
        var t = [];
        fnZ(a, p[1], p[0]);
        fnZ(t, q[1], q[0]);
        fnM(a, a, t);
        fnA(b, p[0], p[1]);
        fnA(t, q[0], q[1]);
        fnM(b, b, t);
        fnM(c, p[3], q[3]);
        fnM(c, c, D2);
        fnM(d, p[2], q[2]);
        fnA(d, d, d);
        fnZ(e, b, a);
        fnZ(f, d, c);
        fnA(g, d, c);
        fnA(h, b, a);
        fnM(p[0], e, f);
        fnM(p[1], h, g);
        fnM(p[2], g, f);
        fnM(p[3], e, h);
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnA(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] + b[i];
        }
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnM(o, a, b) {
        var t = [];
        arrayFill(t, 31);
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++) {
                t[i + j] += a[i] * b[j];
            }
        }
        for (var i = 0; i < 15; i++) {
            t[i] += 38 * t[i + 16];
        }
        arraySet(o, t, 0, 16);
        car25519(o);
        car25519(o);
    }
    /**
     * @param {number[]} o
     * @param {number[]} a
     * @param {number[]} b
     * @private
     * @internal
     */
    function fnZ(o, a, b) {
        for (var i = 0; i < 16; i++) {
            o[i] = a[i] - b[i];
        }
    }
    /**
     * @param {number[][]} p
     * @param {number[]} s
     * @private
     * @internal
     */
    function scalarbase(p, s) {
        var q = [[], [], [], []];
        arraySet(q[0], X);
        arraySet(q[1], Y);
        arraySet(q[2], gf1);
        fnM(q[3], X, Y);
        scalarmult(p, q, s);
    }
    /**
     * @param {number[]} o
     * @private
     * @internal
     */
    function car25519(o) {
        var v;
        var c = 1;
        for (var i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    /**
     * @param {number[]} r
     * @param {number[][]} p
     * @private
     * @internal
     */
    function pack(r, p) {
        var tx = [];
        var ty = [];
        var zi = [];
        inv25519(zi, p[2]);
        fnM(tx, p[0], zi);
        fnM(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    /**
     * @param {number[]} a
     * @returns {number}
     * @private
     * @internal
     */
    function par25519(a) {
        var d = [];
        pack25519(d, a);
        return d[0] & 1;
    }
    /**
     * @param {number[]} o
     * @param {number[]} i
     * @private
     * @internal
     */
    function inv25519(o, i) {
        var c = [];
        arraySet(c, i);
        for (var a = 253; a >= 0; a--) {
            fnM(c, c, c);
            if (a !== 2 && a !== 4) {
                fnM(c, c, i);
            }
        }
        arraySet(o, c);
    }
    /**
     * @param {number[]} p
     * @param {number[]} q
     * @param {number} b
     * @private
     * @internal
     */
    function sel25519(p, q, b) {
        var c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
            var t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    /**
     * @param {number[]} o
     * @param {number[]} n
     * @private
     * @internal
     */
    function pack25519(o, n) {
        var m = [];
        var t = n.slice(0);
        car25519(t);
        car25519(t);
        car25519(t);
        for (var j = 0; j < 2; j++) {
            m[0] = t[0] - 0xffed;
            for (var i = 1; i < 15; i++) {
                m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
            var b = (m[15] >> 16) & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for (var i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    var D = [
        0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
        0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
    ];
    var I = [
        0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
        0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
    ];
    /**
     * Note: difference from C - smlen returned, not passed as argument.
     * @param {number[]|Uint8Array|Buffer} message
     * @param {number[]|Uint8Array|Buffer} secretKey
     * @returns {number[]}
     * @private
     * @internal
     */
    function sign(message, secretKey) {
        var d = sha512(secretKey.slice(0, 32));
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var sm = d.slice(0);
        arraySet(sm, message, 64);
        var r = sha512(sm.slice(32));
        reduce(r);
        var p = [[], [], [], []];
        scalarbase(p, r);
        pack(sm, p);
        arraySet(sm, secretKey.slice(32), 32);
        var h = sha512(sm);
        reduce(h);
        for (var i = 0; i < 32; i++) {
            for (var j = 0; j < 32; j++) {
                r[i + j] += h[i] * d[j];
            }
        }
        return sm.slice(0, 32).concat(modL(sm.slice(32), r).slice(0, 32));
    }
    /**
     * @param {number[]|Uint8Array|Buffer} signature
     * @param {number[]|Uint8Array|Buffer} message
     * @param {number[]|Uint8Array|Buffer} pubKey
     * @returns {boolean}
     * @private
     * @internal
     */
    function verify(signature, message, pubKey) {
        var sm = [];
        var t = [];
        var p = [[], [], [], []];
        var q = [[], [], [], []];
        /** @istanbul ignore if */
        if (!unpackneg(q, pubKey)) {
            return false;
        }
        arraySet(sm, signature, 0);
        arraySet(sm, message, 64);
        var m = sm.slice(0);
        arraySet(m, pubKey, 32);
        var h = sha512(m);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.slice(32));
        add(p, q);
        pack(t, p);
        return cryptoVerify32(sm, t);
    }
    /**
     * @param {number[][]} r
     * @param {number[]|Uint8Array} p
     * @returns {boolean}
     * @private
     * @internal
     */
    function unpackneg(r, p) {
        var t = [];
        var chk = [];
        var num = [];
        var den = [];
        var den2 = [];
        var den4 = [];
        var den6 = [];
        arraySet(r[2], gf1);
        unpack25519(r[1], p);
        fnM(num, r[1], r[1]);
        fnM(den, num, D);
        fnZ(num, num, r[2]);
        fnA(den, r[2], den);
        fnM(den2, den, den);
        fnM(den4, den2, den2);
        fnM(den6, den4, den2);
        fnM(t, den6, num);
        fnM(t, t, den);
        pow2523(t, t);
        fnM(t, t, num);
        fnM(t, t, den);
        fnM(t, t, den);
        fnM(r[0], t, den);
        fnM(chk, r[0], r[0]);
        fnM(chk, chk, den);
        if (!neq25519(chk, num)) {
            fnM(r[0], r[0], I);
        }
        fnM(chk, r[0], r[0]);
        fnM(chk, chk, den);
        /** @istanbul ignore if */
        if (!neq25519(chk, num)) {
            return false;
        }
        if (par25519(r[0]) === (p[31] >> 7)) {
            fnZ(r[0], gf0, r[0]);
        }
        fnM(r[3], r[0], r[1]);
        return true;
    }
    /**
     * @param {number[]} x
     * @param {number[]} y
     * @returns {boolean}
     * @private
     * @internal
     */
    function cryptoVerify32(x, y) {
        var d = 0;
        for (var i = 0; i < 32; i++) {
            d |= x[i] ^ y[i];
        }
        return (1 & ((d - 1) >>> 8)) === 1;
    }
    /**
     * @param {number[]} o
     * @param {number[]} n
     * @private
     * @internal
     */
    function unpack25519(o, n) {
        for (var i = 0; i < 16; i++) {
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 0x7fff;
    }
    /**
     * @param {number[]} o
     * @param {number[]} i
     * @private
     * @internal
     */
    function pow2523(o, i) {
        var c = [];
        for (var a = 0; a < 16; a++) {
            c[a] = i[a];
        }
        for (var a = 250; a >= 0; a--) {
            fnM(c, c, c);
            if (a !== 1) {
                fnM(c, c, i);
            }
        }
        for (var a = 0; a < 16; a++) {
            o[a] = c[a];
        }
    }
    /**
     * @param {number[]} a
     * @param {number[]} b
     * @throws {boolean}
     * @private
     * @internal
     */
    function neq25519(a, b) {
        var c = [];
        var d = [];
        pack25519(c, a);
        pack25519(d, b);
        return cryptoVerify32(c, d);
    }
    /**
     * @param {number[]|Uint8Array|Buffer} seed
     * @returns {number[]}
     */
    function secretKeyFromSeed(seed) {
        var sk = [];
        var pk = [];
        var p = [[], [], [], []];
        arraySet(sk, seed);
        var d = sha512(sk);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        return sk.concat(pk);
    }
    /**
     * @param {number} value
     * @returns {number[]}
     */
    function uint64ToBytes(value) {
        var l = 1;
        var h = (value - l) / 4294967296; // value >>> 32
        return [(h >>> 24) & 0xff, (h >>> 16) & 0xff, (h >>> 8) & 0xff, h & 0xff,
            (l >>> 24) & 0xff, (l >>> 16) & 0xff, (l >>> 8) & 0xff, l & 0xff];
    }
    /**
     * @param {number[]} bytes
     * @returns {number}
     * @throws {Error}
     */
    function bytesToUint64(bytes) {
        if (((bytes[0] << 8) + bytes[1]) > 0x001f) {
            throw new Error('value is not safe integer');
        }
        var h = (bytes[69] << 24) + (bytes[70] << 16) + (bytes[71] << 8) + bytes[72];
        var l = (bytes[73] << 24) + (bytes[74] << 16) + (bytes[75] << 8) + bytes[76];
        return (h * 4294967296) + l; // h << 32 | l
    }
    var sha256K = [
        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
    ];
    /**
     * Безопасный алгоритм хеширования, SHA2-256.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]|Uint8Array|Buffer} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha256(message) {
        // SHA-256 initial hash values.
        var h = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha256PreProcess(message);
        // Process the message in successive 512-bit chunks / 16 32-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 64; i++) {
                var s0 = rotr(w[i - 15], 7) ^ rotr(w[i - 15], 18) ^ (w[i - 15] >>> 3);
                var s1 = rotr(w[i - 2], 17) ^ rotr(w[i - 2], 19) ^ (w[i - 2] >>> 10);
                w[i] = w[i - 16] + s0 + w[i - 7] + s1;
            }
            // Compression function main loop.
            sha256Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v >>> 24 & 0xff), (v >>> 16 & 0xff), (v >>> 8 & 0xff), (v & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]|Uint8Array|Buffer} message
     * @returns {number[][]}
     */
    function sha256PreProcess(message) {
        var bytes = [];
        // Length a multiple of 512 bits
        for (var i = 0, l = message.length + 8 + (64 - ((message.length + 8) % 64)); i < l; i++) {
            bytes[i] = message[i] || 0;
        }
        bytes[message.length] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 64-bit big-endian integer
        bytes[bytes.length - 2] = ((message.length * 8) >>> 8) & 0xff;
        bytes[bytes.length - 1] = (message.length * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytes.length; i < l; i += 64) {
            var chunk = [];
            for (var j = 0; j < 64; j += 4) {
                var n = i + j;
                chunk.push((bytes[n] << 24) + (bytes[++n] << 16) + (bytes[++n] << 8) + bytes[++n]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {number[]} h
     * @param {number[]} w
     */
    function sha256Block(h, w) {
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = v; // deep copy
        });
        for (var i = 0; i < 64; i++) {
            var S1 = rotr(a[4], 6) ^ rotr(a[4], 11) ^ rotr(a[4], 25);
            var ch = (a[4] & a[5]) ^ ((~a[4]) & a[6]);
            var t1 = a[7] + S1 + ch + sha256K[i] + w[i];
            var S0 = rotr(a[0], 2) ^ rotr(a[0], 13) ^ rotr(a[0], 22);
            var ma = (a[0] & a[1]) ^ (a[0] & a[2]) ^ (a[1] & a[2]);
            var t2 = S0 + ma;
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = a[3] + t1;
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = t1 + t2;
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = h[i] + v | 0; // clamp 32bit
        });
    }
    /**
     * @param {number} n
     * @param {number} i
     * @returns {number}
     */
    function rotr(n, i) {
        return (n >>> i) | (n << (32 - i));
    }
    var sha512K = [
        [0x428a2f98, 0xd728ae22], [0x71374491, 0x23ef65cd], [0xb5c0fbcf, 0xec4d3b2f], [0xe9b5dba5, 0x8189dbbc], [0x3956c25b, 0xf348b538],
        [0x59f111f1, 0xb605d019], [0x923f82a4, 0xaf194f9b], [0xab1c5ed5, 0xda6d8118], [0xd807aa98, 0xa3030242], [0x12835b01, 0x45706fbe],
        [0x243185be, 0x4ee4b28c], [0x550c7dc3, 0xd5ffb4e2], [0x72be5d74, 0xf27b896f], [0x80deb1fe, 0x3b1696b1], [0x9bdc06a7, 0x25c71235],
        [0xc19bf174, 0xcf692694], [0xe49b69c1, 0x9ef14ad2], [0xefbe4786, 0x384f25e3], [0x0fc19dc6, 0x8b8cd5b5], [0x240ca1cc, 0x77ac9c65],
        [0x2de92c6f, 0x592b0275], [0x4a7484aa, 0x6ea6e483], [0x5cb0a9dc, 0xbd41fbd4], [0x76f988da, 0x831153b5], [0x983e5152, 0xee66dfab],
        [0xa831c66d, 0x2db43210], [0xb00327c8, 0x98fb213f], [0xbf597fc7, 0xbeef0ee4], [0xc6e00bf3, 0x3da88fc2], [0xd5a79147, 0x930aa725],
        [0x06ca6351, 0xe003826f], [0x14292967, 0x0a0e6e70], [0x27b70a85, 0x46d22ffc], [0x2e1b2138, 0x5c26c926], [0x4d2c6dfc, 0x5ac42aed],
        [0x53380d13, 0x9d95b3df], [0x650a7354, 0x8baf63de], [0x766a0abb, 0x3c77b2a8], [0x81c2c92e, 0x47edaee6], [0x92722c85, 0x1482353b],
        [0xa2bfe8a1, 0x4cf10364], [0xa81a664b, 0xbc423001], [0xc24b8b70, 0xd0f89791], [0xc76c51a3, 0x0654be30], [0xd192e819, 0xd6ef5218],
        [0xd6990624, 0x5565a910], [0xf40e3585, 0x5771202a], [0x106aa070, 0x32bbd1b8], [0x19a4c116, 0xb8d2d0c8], [0x1e376c08, 0x5141ab53],
        [0x2748774c, 0xdf8eeb99], [0x34b0bcb5, 0xe19b48a8], [0x391c0cb3, 0xc5c95a63], [0x4ed8aa4a, 0xe3418acb], [0x5b9cca4f, 0x7763e373],
        [0x682e6ff3, 0xd6b2b8a3], [0x748f82ee, 0x5defb2fc], [0x78a5636f, 0x43172f60], [0x84c87814, 0xa1f0ab72], [0x8cc70208, 0x1a6439ec],
        [0x90befffa, 0x23631e28], [0xa4506ceb, 0xde82bde9], [0xbef9a3f7, 0xb2c67915], [0xc67178f2, 0xe372532b], [0xca273ece, 0xea26619c],
        [0xd186b8c7, 0x21c0c207], [0xeada7dd6, 0xcde0eb1e], [0xf57d4f7f, 0xee6ed178], [0x06f067aa, 0x72176fba], [0x0a637dc5, 0xa2c898a6],
        [0x113f9804, 0xbef90dae], [0x1b710b35, 0x131c471b], [0x28db77f5, 0x23047d84], [0x32caab7b, 0x40c72493], [0x3c9ebe0a, 0x15c9bebc],
        [0x431d67c4, 0x9c100d4c], [0x4cc5d4be, 0xcb3e42b6], [0x597f299c, 0xfc657e2a], [0x5fcb6fab, 0x3ad6faec], [0x6c44198c, 0x4a475817]
    ];
    /**
     * Безопасный алгоритм хеширования, SHA2-512.
     * @see https://en.wikipedia.org/wiki/SHA-2
     * @param {number[]|Uint8Array|Buffer} message message
     * @returns {number[]} hash
     * @private
     * @internal
     */
    function sha512(message) {
        // SHA-512 initial hash values.
        var h = [
            [0x6a09e667, 0xf3bcc908], [0xbb67ae85, 0x84caa73b], [0x3c6ef372, 0xfe94f82b], [0xa54ff53a, 0x5f1d36f1],
            [0x510e527f, 0xade682d1], [0x9b05688c, 0x2b3e6c1f], [0x1f83d9ab, 0xfb41bd6b], [0x5be0cd19, 0x137e2179]
        ];
        // Chunk contains first 16 words w[0..15] of the message schedule array.
        var chunks = sha512PreProcess(message);
        // Process the message in successive 1024-bit chunks / 16 64-bit words.
        chunks.forEach(function (w) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array.
            for (var i = 16; i < 80; i++) {
                var s0 = xor64(xor64(rotr64(w[i - 15], 1), rotr64(w[i - 15], 8)), shft64(w[i - 15], 7));
                var s1 = xor64(xor64(rotr64(w[i - 2], 19), rotr64(w[i - 2], 61)), shft64(w[i - 2], 6));
                w[i] = sum64(sum64(w[i - 16], s0), sum64(w[i - 7], s1));
            }
            // Compression function main loop.
            sha512Block(h, w);
        });
        var digest = [];
        h.forEach(function (v) {
            digest.push((v[0] >>> 24 & 0xff), (v[0] >>> 16 & 0xff), (v[0] >>> 8 & 0xff), (v[0] & 0xff));
            digest.push((v[1] >>> 24 & 0xff), (v[1] >>> 16 & 0xff), (v[1] >>> 8 & 0xff), (v[1] & 0xff));
        });
        return digest;
    }
    /**
     * @param {number[]|Uint8Array|Buffer} message
     * @returns {[number, number][][]}
     */
    function sha512PreProcess(message) {
        var bytez = [];
        // Length a multiple of 1024 bits
        for (var i = 0, l = message.length + 16 + (128 - ((message.length + 16) % 128)); i < l; i++) {
            bytez[i] = message[i] || 0;
        }
        bytez[message.length] = 0x80; // Append a single '1' bit
        // Append message length in bits as a 128-bit big-endian integer
        bytez[bytez.length - 2] = ((message.length * 8) >>> 8) & 0xff;
        bytez[bytez.length - 1] = (message.length * 8) & 0xff;
        var chunks = [];
        for (var i = 0, l = bytez.length; i < l; i += 128) {
            var chunk = [];
            for (var j = 0; j < 128; j += 8) {
                var n = i + j;
                chunk.push([
                    (bytez[n] << 24) + (bytez[++n] << 16) + (bytez[++n] << 8) + bytez[++n],
                    (bytez[++n] << 24) + (bytez[++n] << 16) + (bytez[++n] << 8) + bytez[++n]
                ]);
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    /**
     * @param {[number, number][]} h
     * @param {[number, number][]} w
     */
    function sha512Block(h, w) {
        // Initialize working variables to current hash value.
        var a = [];
        h.forEach(function (v, i) {
            a[i] = [v[0], v[1]]; // deep copy
        });
        // Compression function main loop.
        for (var i = 0; i < 80; i++) {
            var S1 = xor64(xor64(rotr64(a[4], 14), rotr64(a[4], 18)), rotr64(a[4], 41));
            var ch = xor64(and64(a[4], a[5]), and64(not64(a[4]), a[6]));
            var t1 = sum64(sum64(sum64(a[7], S1), sum64(ch, sha512K[i])), w[i]);
            var S0 = xor64(xor64(rotr64(a[0], 28), rotr64(a[0], 34)), rotr64(a[0], 39));
            var ma = xor64(xor64(and64(a[0], a[1]), and64(a[0], a[2])), and64(a[1], a[2]));
            var t2 = sum64(S0, ma);
            a[7] = a[6];
            a[6] = a[5];
            a[5] = a[4];
            a[4] = sum64(a[3], t1);
            a[3] = a[2];
            a[2] = a[1];
            a[1] = a[0];
            a[0] = sum64(t1, t2);
        }
        // Add the compressed chunk to the current hash value.
        a.forEach(function (v, i) {
            h[i] = sum64(h[i], v);
        });
    }
    function shft64(n, i) {
        return [(n[0] >>> i), (n[1] >>> i) | (n[0] << (32 - i))];
    }
    function rotr64(n, i) {
        if (i < 32) {
            return [n[0] >>> i | n[1] << (32 - i), n[1] >>> i | n[0] << (32 - i)];
        }
        return [
            n[1] >>> (i - 32) | n[0] << (32 - (i - 32)),
            n[0] >>> (i - 32) | n[1] << (32 - (i - 32))
        ];
    }
    function xor64(a, b) {
        return [(a[0] ^ b[0]), (a[1] ^ b[1])];
    }
    function and64(a, b) {
        return [(a[0] & b[0]), (a[1] & b[1])];
    }
    function not64(n) {
        return [~n[0], ~n[1]];
    }
    /**
     * @param {[number, number]} a
     * @param {[number, number]} b
     * @returns {[number, number]}
     * @private
     * @internal
     */
    function sum64(a, b) {
        var x = [0, 0, 0, 0];
        x[3] = (a[1] & 0xffff) + (b[1] & 0xffff);
        x[2] = (a[1] >>> 16) + (b[1] >>> 16) + (x[3] >>> 16);
        x[1] = (a[0] & 0xffff) + (b[0] & 0xffff) + (x[2] >>> 16);
        x[0] = (a[0] >>> 16) + (b[0] >>> 16) + (x[1] >>> 16);
        return [((x[0] & 0xffff) << 16) + (x[1] & 0xffff), ((x[2] & 0xffff) << 16) + (x[3] & 0xffff)];
    }
    /**
     * Конвертер строки в типизированный массив UTF-8 байтов.
     * @function
     * @param {string} text
     * @returns {number[]}
     * @private
     */
    function Utf8Encode(text) {
        var bytes = [];
        for (var i = 0; i < text.length; i++) {
            var code = text.charCodeAt(i);
            if (code < 0x80) { // ascii
                bytes.push(code);
            }
            else if (code < 0x800) {
                bytes.push(0xc0 | (code >> 6), 0x80 | (code & 0x3f));
            }
            else if (code < 0xd800 || code >= 0xe000) {
                bytes.push((0xe0 | (code >> 12)), (0x80 | ((code >> 6) & 0x3f)));
                bytes.push(0x80 | (code & 0x3f));
            }
            else { // surrogate pair
                code = 0x10000 + ((code & 0x3ff) << 10) + (text.charCodeAt(++i) & 0x3ff);
                bytes.push((0xf0 | (code >> 18)), (0x80 | ((code >> 12) & 0x3f)));
                bytes.push((0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)));
            }
        }
        return bytes;
    }
    /**
     * Конвертер из типизированного массива UTF-8 байтов в строку.
     * @function
     * @param {number[]|Uint8Array|Buffer} bytes
     * @returns {string}
     * @private
     */
    function Utf8Decode(bytes) {
        var str = '';
        for (var i = 0; i < bytes.length; i++) {
            if (bytes[i] < 0x80) { // ascii
                str += String.fromCharCode(bytes[i]);
            }
            else if (bytes[i] > 0xBF && bytes[i] < 0xE0) {
                str += String.fromCharCode((bytes[i] & 0x1F) << 6 | bytes[++i] & 0x3F);
            }
            else if (bytes[i] > 0xDF && bytes[i] < 0xF0) {
                str += String.fromCharCode((bytes[i] & 0x0F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F);
            }
            else { // surrogate pair
                var code = ((bytes[i] & 0x07) << 18 | (bytes[++i] & 0x3F) << 12 |
                    (bytes[++i] & 0x3F) << 6 | bytes[++i] & 0x3F) - 0x010000;
                str += String.fromCharCode(code >> 10 | 0xD800, code & 0x03FF | 0xDC00);
            }
        }
        return str;
    }
    /**
     * @param {number} arg
     * @param {number} min
     * @param {number} max
     * @throws {Error}
     */
    function validateInt(arg, min, max) {
        if (typeof arg !== 'number') {
            throw new Error('incorrect type');
        }
        if (Math.floor(arg) !== arg) {
            throw new Error('not integer');
        }
        if (arg < min || arg > max) {
            throw new Error('incorrect value');
        }
    }
    /**
     * @param {string} arg
     * @param {number} [len]
     */
    function validateStr(arg, len) {
        if (typeof arg !== 'string') {
            throw new Error('incorrect type');
        }
        if (len !== undefined && arg.length !== len) {
            throw new Error('incorrect length');
        }
    }

    exports.Address = Address;
    exports.Block = Block;
    exports.BlockHeader = BlockHeader;
    exports.PublicKey = PublicKey;
    exports.SecretKey = SecretKey;
    exports.Transaction = Transaction;

    return exports;

}({}));
